Tanstack Router Full Course - YouTube
https://www.youtube.com/watch?v=8_sGz4DHwIA

Transcript:
(00:00) Today we are taking a look at tenstack router. So tenstack router is a router that you can use to build react and solid applications. And what makes uh tenstack router special is that it is 100% type safe. So if we take a look here it offers uh pretty much the same features that you will find in any other router like in Nex.js or in react router.
(00:26) So we have nested layouts uh layout groups. We have filebased routing, par parallel data loading, prefetching and so on. However, we also have 100% inferred TypeScript support. Everything that we are going to do that is related to navigation is going to be 100% type safe. Uh we also have stuff like built-in caching. We're going to take a look at that.
(00:45) You can also integrate it with uh things like tstack query. It also offers a lot of convenient features when dealing with uh search parameters. So we can do things like validating our search parameters. We can also make our search parameters type safe and we can also easily manipulate our search parameters in a very easy way.
(01:04) And we're going to take a look at all of that. We also have other features like context for example where we can pass some context some state that is going to be shared across multiple routes. We can use it for authentication for example to share authentication data in order to protect certain routes.
(01:25) We also have other features like loading functions or loader functions that we can use in order to load data into our routes. We can also stream data. We can do a lot of stuff. So let's not talk a lot and let's get started. And all of these features are going to manifest as we progress through our video. Uh what you need to know however is that uh 10stack router is not a framework.
(01:45) So it is not meant to be used as a full stack framework. However, it is designed to be upgradable to a full stack framework and in fact it is powering 10 stacks u full stack framework which is 10stack start which is currently in beta. This uses react router for routing and uh if you are interested in learning ten stack start at some point you will have to be familiar with tanstack router.
(02:09) So maybe this video is going to be helpful for you. Also in here if you are interested you can find a comparison table between different famous react routers. So we have tensstack router, we have react router and we have the router that comes with Nex.js. You can take a look at that.
(02:28) Uh it might help you decide which router to use if you are uh working on a new project. However, let's get started right away and create a new application and use stack router inside of it. [Applause] [Music] So let's install a new stand stack router and in order to do that I'm going to create a new react project however without using any framework without using nex.js or any uh framework like that.
(02:58) What I'm going to do is I'm going to create a new uh react project with only vit as a bundler. So tanstack router supports multiple bundlers including vit uh which we're going to use. It also supports Webpack, ES Build, uh, and I think maybe others as well, but we're going to use VIT in order to create a new VIT project. Uh, let's maybe put this in my desktop.
(03:23) And I'm going to, uh, run mpm create and then vit at latest. And we're going to get a list of options. So, let's choose a name. Let's say 10 stack router. And let's choose a framework. Of course, we're going to use React. Uh by the way uh as we've mentioned tstack router supports solid as well over we're going to use react here.
(03:47) So let's choose react and in here by the way we can have uh we can select a template that already includes tanstack router. However I'm not going to do that because I would like to show you how to install tan uh stack router from scratch if you are for example using tan stack router in an existing project. So what I'm going to do is I'm just going to choose typescript.
(04:06) So let's choose TypeScript here and our project should be created in our desktop. Let's move to it and then let's run npm install. And I'm also going to open this project on my code editor. So now I have my project opened on VS Code and I've also installed my dependencies. But now let's install Tanstack router.
(04:31) I'm also going to install uh Tailwind in order to do quick styling while we are having some examples throughout the video. So in order to install tanstack router we need to install these packages. So I'm going to do uh mpm install and as you can see we have here tanstack uh at tanstack react router and at 10stack react router dev tools. We need to install these and also as dev dependencies we need to have a a vit plugin.
(04:57) So after this is done, let's also install as a dev dependency tenstack router plugin. Let's run this. And then uh for Tailwind, I'm also going to add one more installation here which is npm install Tailwind CSS and Tailwind Vit. Right? So this is all what we need. Now we need to go into our Vit config in here and we need to do some stuff. So first of all we need to import our tailwind uh vit plugin. So let's do that here.
(05:30) And also we need to import our tan stack router v plugin which we can do by importing tstack router from from this import. And uh I'm also going to turn off um copilot completions because I think it's going to be annoying for you. However, what we need to do is simply uh use these plugins here in this plugins array for 10 stack router.
(05:55) We need to define it before the react one. So in here we can put 10 stack router like so. And we can pass options for now. Let's only pass target which is going to be react. It can be solid as well. And then we also need to add the Tailwind plugin in order to use Tailwind uh in our app.
(06:21) And now what we need to do uh is just in order to use tailwind let's go to the uh main styles index.tss here and let's import tailwind like so. I am also going to maybe remove some of these uh default styles. Let's maybe remove everything but maybe let's keep the uh let's keep the button styles. For example, let's maybe remove this H1 body. uh just remove these and keep the root styles, the button styles and uh the styles for dark mode or light mode as well. So this should be our app.
(07:01) Let's try to run it by running mpm rundev and let's try to open it in our browser. We have an error here. Uh we can ignore this for now, but let's now open this URL in our browser like so. And now we have this app and now we can start working with tanstack router. In tanstack router to create a router we need to compose a tree where we are going to have a root node.
(07:23) So we're going to have some root route and this is going to be the root of our tree. It is always going to exist. It has no path and it is always matched which means the component that we're going to define in this root node is always going to exist. But now as children to this root node we can create our routes. So we can have maybe couple of routes.
(07:44) Let's say uh we have a home route and let's say we also have a slash about route and of course this can go on we can have other children to about and so on. So in order to create a 10stack router we need to create this tree somehow and we can do that in a couple of ways. First code based and second filebased. Let's try code based uh first and then we're going to see that maybe it is not the ideal way to create our router and we're going to move to filebased uh after it. But let's first see how can we create a code-based router. So in here
(08:23) uh in our app we have this main.tsx file and in here we are we are rendering this app component which we can find here uh that displays these logos and this uh counter component and so on. However, of course we're not going to use that. We're going to instead render a new router.
(08:43) So let's remove this and let's remove app and let's create our router and put it here instead. So first of all, as we've mentioned, we're going to have this root route. So how can we create this? We can do uh create a new constant. Let's call it root route. And then we can call a function create root route which is imported from uh from tstack react router.
(09:08) And in here we composite a component that is going to be rendered. And as we've mentioned this component is going to exist for all routes. It's going to be the parent of all routes. So in here in this object we can pass a component. And uh it's going to be just a function that returns some JSX. So in here I'm maybe going to put some div for now.
(09:30) And this div uh just has a background color and also some text root route. And now let's save this and create our children. So we need to create a home route and a /about route. To do that using the the codebased approach, we also similarly create a new constant. Let's call it index route or home route. And in this case we call a function create uh create route.
(09:52) So create route. And then we pass it some options as well. First of all, we need to make sure to indicate that this index route is a child of our root route. So to do that, we use an option here, get parent route. And this is going to be a function that returns the parent route, which is root route.
(10:18) We have to do this for all of our routes in order to make sure we get the type safety features uh that we're going to see later. Then we uh specify the path that is going to be matched for this route, which is forward slash. This is our home route. And then of course we specify a component as well that's going to be rendered when we visit this route.
(10:36) So of course we can create these components in separate files and then import them here. But since uh this is just an example, I'm going to put the component here in the same file. Just a very simple component that uh displays a div with some background color and a text of home as well. And similarly I'm going to create the about route as well which is going to be exactly the same. So I'm going to put this here about route.
(10:59) We specify the parent the path /about and another component with some text that says about here. And now by having these we need to construct our tree. So to do that we define our tree. So let's create a constant router or let's say route tree and we get our root route and we call a function called add children. So yes we have to do that.
(11:24) Even though we specify that this route is a child of the root route, we still have to define our tree by adding children to our root route. So in here, we can add an array of children. In our case, we have the index route and we have the about route. And of course, this tree can be bigger. We can have we can add children to about route and so on. But let's keep it simple for now.
(11:50) Finally, we create our router. So let's create our router and to do that we call a function create router. So create router from tst sorry and poset our tree like so in an option called route tree. So we pass it the route tree that we define here. And now finally we need to render our router.
(12:16) So inside of here instead of rendering this app component we need to render our router. So, so what this does, it gets an element with an id of root. So, if we take a look at our index.html we have a div with a with an id of root and inside of here we need to render our app which is going to be our router. So, we get this element and then render and inside of strict mode here we can import a function called router provider from 10 stack and then pass it the router that we created here. So, router and pass our router. Now if we save as you
(12:50) can see we get our root route. However uh currently we are visiting our home. So we should get this home text as well but we're not getting that because in our root route we need to render our children. So this root route is going to have children. We need to render these. And to do that in tenstack router we use a component called outlet.
(13:12) So by adding outlet here we're going to get our children. And now we can go to home. We can go to about as well. All right. In here we can also add our dev tools. So remember when we installed tanstack router, we also installed some dev tools. If we import from these dev tools, tanstack router dev tools component like so.
(13:37) Remember this is imported from here. Tanstack react router dev tools and save. We're going to get this. We can also change its uh position. So we can put it maybe in the top right. Let's say we're going to get it here. If we click on this, it is going to contain a lot of useful information uh that we're going to see more throughout uh the video.
(14:02) However, what we can do for example, currently we don't have any links to navigate between home and about. We can do that from here. In here we are going to get our routes and the ones marked in green here are going to be the currently matched routes or currently rendered components. So we are in home.
(14:20) So the rendered components are going to be the root and the home component. So this is what we get here. Root and then home. And we can go to about by clicking on this arrow. And now the green ones are going to be root and about and so on. Of course, as we create more complex routes, this is going to be more useful where it is going to show uh the tree how the tree looks like if we have a lot of nested stuff and so on.
(14:48) But now let's see how can we navigate between routes uh in 10 stack router. So let's say we need to have some navigation bar common between all of our routes where we're going to be able to navigate between home and about. So as we can see this root component is common between our home and about. So, we can put our navigation here.
(15:07) And of course, later we're going to see how to add other custom layouts as well that can be shared across multiple routes. But for now, let's use the root route. So, in here, maybe after uh this text and before our outlet, let's add this navigation bar. So, I'm going to add a div. Uh let's add a class of um P2 for padding. Let's also add flex. Let's add a gap of two. Let's also add some margin bottom.
(15:32) And finally some some background color as well. And inside of here I'm going to add a couple of links. So in order to navigate in 10 stack router we use this link component that we can import from uh tst route. In here uh we can just put some text. So let's say home and then in here we can put two in order to specify where we are navigating to.
(15:56) So in in this case we're navigating to forward slash or home route. And we can maybe duplicate this. Add another one for about. And in here slashabout. I'm also going to make this background maybe a little darker. Uh so that we can have some contrast. Uh let's just make it blue, dark blue. Like so.
(16:16) Anyways, now we can click on about navigate to about click on home to navigate and home. We can also highlight the currently active route and this can be done in multiple ways in 10 stack router. So first of all we can add um or actually let's let's maybe inspect here and if we take a look at uh the links generated by this link component we are going to find out that the currently active link is going to have this data status active and also it's going to have a class of active already.
(16:46) So we can use that in order to maybe do some different styling. So since we are using tailwind we can do that by adding here if we have a class of active so and do.active if we have that we can add maybe font bold and we can do that for the other link as well. So now home is bold about is bold and so on. We can also make use of this instead of the class we can make use of the data status active as well.
(17:19) Also we have another option where we can specify active props in here. So in active props we can add a style. Oh sorry style and then in style we can add some styles and so on. However, I'm going to use this active class. So this is great. However, if we try to maybe um in our link component try to link to some route that does not exist, we don't get any TypeScript errors.
(17:46) And as we've mentioned, one of 10 stack routers unique features is its type safety. But we don't get any type safety here. So in order to achieve type safety, we need to do something first. So in here after defining our tree and our router and so on, we need to declare some module. So in here we can use typescript declare sorry declare and then declare module and then extend 10 stack.
(18:14) So in here we put the tenstack module name at tenstack react router and then we need to extend this register interface. So in here we add interface register and we need to put our router here the type of our router. So in here we put router and then type of and then the router that we defined here in this constant.
(18:37) So now since we defined this tree here using um root route add children and in the children we specify the parent and so on. Now tense stack router is going to be aware of your current route's position in the tree and it's going to be able to infer types correctly. And by declaring this router module here or router type in this register interface anywhere we use something like the link component we're going to get type safety.
(19:08) So in here as you can see we already we're already getting an error here because we don't have this route. But if we change this back to about we don't get any errors. And also if we remove this and maybe add a string here we get autocomplete as well for our currently existing routes. As you can see we also have some relative paths as well. We're going to see this later but for now let's keep this as about.
(19:31) And of course, these uh type safety features are not only going to apply to this link component, but anywhere we do anything uh related to navigation, we're going to get type safety as well. And of course, we're going to see that throughout the video. So that was a basic example on the codebased approach in order to create this router. We created everything using code. We haven't created any files to define our routes.
(19:57) However, this is not the preferred way to create your router. As you can imagine, if you have a lot of routes, a lot of nesting, a lot of features in your application, you're going to have to do to define every route yourself, define the component, define the path, add this uh parent route thing, uh compose your tree manually here.
(20:23) And of course, doing all of that yourself for a lot of routes, you are going to probably have some mistakes here and there, and your router is going to be more prone to bugs and errors. Using the file-based approach that we're going to see now lets us define our routes by creating folders, a tree of folders. And by doing so, tense tech is going to generate all of that for us. All of that boiler plate is going to be generated.
(20:44) We don't have to specify the parent route. We don't have to specify the path. we don't have to construct uh this tree ourselves and so on. And therefore, if you open the documentation for tanstack, this is going to be mentioned a lot that um the file-based uh routing approach is the preferred way.
(21:02) And throughout the documentation uh the file-based approach is going to be used in most of the examples. So next we're going to see how to convert what we've done using the code- based approach uh but now using the filebased approach and throughout the video we are going to continue using the filebased approach.
(21:21) However just keep in mind that anything that we can do with the file-based approach can be done with the codebased approach as well if you would like to do so. And also if you'd like you can uh take a look at this if you would like to read more about why the file-based approach is the preferred way.
(21:40) So let's now convert our couple of routes that we've created into the filebased approach. So first of all what we need to do is in our source folder we need to create a folder called routes. So let's create a new folder routes. And this name can be customized by the way but by default it should be routes.
(22:00) And now we need to move the root route the index route and the about route into files inside of this folder. So in here in order to create the root route we create a new file and it should be called underscore_root. CSX and then as we create this as you can see without us doing anything some code is going to be autogenerated here.
(22:26) So instead of us having to call create root route ourselves and pass the component and so on when you create this file this is going to be autogenerated. And now in here uh we can maybe just copy our component from here and put it here. And uh just need to import our stuff. So link and the dev tools. Oh, sorry. The dev tools like so. Now we can save this. Uh we don't need this by the way. And now we can just remove this from the old file.
(23:00) Now we need to do the same for the index route and the about route. So simply in our routes folder can create a new file about thetsx and as you can see this is going to be autogenerated. We don't have to specify this path ourselves. If we rename the file this is also going to be automatically updated. We don't have to do anything.
(23:23) And we get this component passed here. And now we can just simply uh this is the about. So, let's copy the about component, put it here, and finally, let's do the one for the index. Let's remove this one from here. And for the index, we're going to need to uh create a file called index tsx as well.
(23:49) And also simply copy the stuff from here, put it here, and remove this from here. All right. By doing this, if we take a look at our folder, we're going to find out this route tree generated for us. So this route tree.jen.ts. If we open this, this is the route tree that we manually created here when we used the codebase uh code based approach.
(24:18) Now when using the file-based approach, this is going to be automatically generated for us. So we have some uh TypeScript related stuff also generated and uh we have our tree here created for us and this is the one that we can import and use in order to initialize our router. So instead of this now we can remove this and import the one from this generated file.
(24:41) So let's import like so from our route.gen gen this generated router tree and password to create router and let's also remove the unused imports and uh I guess this should be it so let's save let's refresh here and as you can see everything is still working the same but as you've seen here when we um create a route so for example in this about tsx or index tsx we have to pass the path as well and this is in order to get type safety uh related stuff even Though this path can be inferred maybe from the file name. So the file name is about. So maybe this can be inferred to be /about. However, we still have to
(25:23) pause it in order for type safety to work. However, as we've mentioned, we don't have to pause it manually. This is going to be generated for us. If we for example change this, as you can see, we get an error. So if we accidentally change this, we're going to get an error.
(25:39) Also, if we change the folder name, it is going to be automatically updated for us. So let's say about us for example. Now as you can see this is automatically updated over let's get it back to about. And in here it should get back to about. If you get an error here after renaming the file, I'm not sure why this is happening, but when I sometimes when I rename the file, this route three uh generated file is automatically opened and when I just close it and don't save anything, uh this is going to be uh the error is going to be gone. Not sure why
(26:15) this is happening, but uh anyways, you can just close the uh generated tree file. So, as you can see, with this file-based approach, a lot of stuff is going to be happening for us behind the scenes. We managed to make this file a lot smaller. We don't have to define any routes ourselves. Uh this tree is going to be generated for us.
(26:38) And also if we take a look here, we get a lot of benefits as well. So simplicity, it is much easier to understand what is going on when your routes are organized in a folder which also makes our code a lot more organized, a lot more scalable. We don't have to do uh a lot of stuff manually ourselves.
(26:56) Later we are also going to see that we can do code splitting easily when we use the file-based approach as opposed to the code based approach where we are going to need to do a lot of stuff manually. And of course we're going to get a lot of type safety features out of the box by allowing tenstack router to generate a lot of types script related stuff uh when we use this file based approach.
(27:17) But now that we are using the file-based approach, let's now focus on exploring more features in tanstack router. And let's start with nested routes and layouts. Let's now see how can we nest routes in tanstack router. We can do that in a couple of ways.
(27:37) First, we can just uh create folders or directories and nest them inside of each other. And this way, we're simply going to have nested routes. or we can name our file in a certain way that is going to indicate that a route is nested inside of a another route. But let's first start with uh the maybe the more straightforward one which is using folders.
(27:56) So let's say in our routes uh folder we have another folder called settings. Now inside of settings we can create nested routes. So let's say we're going to have settings/profile for example. So profile.tsx inside of settings. And as you can see, we have this autogenerated for us. And the path is going to be settings/profile.
(28:20) But now, let's say we're also going to have maybe another route inside of settings. Let's say maybe payment.tsx. And we're going to have this uh generated for us as well with the path of settings/payment. In the autogenerated code, we have this div. I'm just going to add some classes uh in order to see things. uh just some background color and padding and so on.
(28:45) So for payment and uh let's also do it for the other one which is profile as well like so. So now uh let's maybe open this these dev tools and now we can see here in our tree that we now have a couple of routes settings/payment and settings/profile but notice that we don't have settings itself. So we can go to settings / payment and this is what we're going to see. We can go to settings/profile.
(29:10) We're going to get this. However, if we go to settings itself without uh slash anything, this is not found. But let's say we need this to be matched as well / settings without any other segment. So this can be done in a couple of ways. We can have settings be its own route or we can have settings as a parent to settings/profile and settings/ uh payment. So let's try to visualize this.
(29:38) So imagine we have our tree, we have our root route which is always going to exist. We can also have our uh home route, about route and so on. But let's now focus on the route that we just created which is this one. Let's say this is the settings one. So we can have settings. Currently it is not matched but we can have it as apparent to the other two routes which are payment and um profile or whatever or we can have it be its own route.
(30:09) So we can have our root route and then we can have settings as its own route not as a parent and then we can have settings/ profile settings/ payment. All of these are going to be three separate routes. And of course, based on what you need, you can choose uh one of these approaches.
(30:33) If you choose this one where settings is apparent, you'll have to render an outlet because now settings is going to be matched for settings and settings/profile and settings/ payment. So the component that you're going to define here is going to uh exist for all of these routes. And if we have children, we're going to need to render an outlet to display our children. similar to what we have in our root route and our children.
(30:56) However, if we do it this way, now settings is going to be a separate route and we don't need to have an outlet is not going to have any children. So, let's see that in action. Let's maybe first uh do the approach where we're going to have uh three separate routes, right? So in order to do that, we can go to our folder and inside of settings, in order for settings to be matched, we can create an index.tsx file here.
(31:25) And notice when we do so, the path created here is going to have a trailing slash at the end. This means that this component or this route is only going to be matched if our URL is exactly / settings and not / settings uh/ something else. So this way / settings is just a child of root. It is not a parent to settings/ something.
(31:52) So if we take a look here in our dev tools, we're going to find that uh we have settings as a sibling to settings/ profile and settings/ payment. It is not apparent, right? And it is not going to be matched. So currently it is green because our URL is exactly SL settings. However, if we go to settings/profile, this is not going to be green. It is not going to be matched.
(32:16) Right? So, this way we have settings as a separate completely unrelated uh route to settings/profile and settings/p paying. Right? What if we would like to have this approach though where settings is going to act as a layout to uh any route that starts with settings/ something. Now, in this case, instead of index.tsx, tsx.
(32:44) We're going to have to rename this to route.tsx. So, let's in here rename this into route.tsx. And now, um, as you can see here in the generated file, we don't have this trailing slash, which means this route, this component is going to be matched for anything that starts with settings and of course settings itself. And if we take a look at our dev tools, we're going to find now that settings is apparent uh to payment and to profile.
(33:13) And also uh when we have when we are visiting settings/profile settings is matched is green and profile is also green. If you go to payment uh settings is going to be green, payment green. If you go to settings only uh by clicking on this arrow then only settings is going to be green and we're going to get the settings page.
(33:37) If we go to payment and profile however uh nothing is changing here because now that settings is apparent to profile and payment we need to render an outlet. Right? So in settings and then route to tsx we need to put an outlet here in order to render our children. So we can import outlet, put it here, save and uh we're going to get our stuff. We can navigate to payment profile and so on.
(34:02) However, the component that we defined inside of settings um sorry inside of route.tsx in settings is always going to exist which is this one. So we have our root route, we have our settings and then we have whatever route we are visiting either payment or profile right we can also maybe uh have some I'm going to put some code here to navigate between uh payment and profile inside of settings.
(34:34) So in the settings sort of parent or layout we can maybe put here this div this import link that is going to go to settings/ payment or settings/profile. And of course uh by the way now we since we have more routes uh we're going to get these as well in the um autocomplete and so on. And now if we save this, we're going to have these navigation links where we can navigate inside of settings between payment and profile.
(35:09) But now let's say we have a case where we have um a route which is settings/ something also. However, we need this new route to not use the settings route as a parent. So let's say we have um another route which is setting/ something as well. However, we need we need it to be uh a direct child to the root like so and not a child to settings like so.
(35:35) So, how can we do that? Because if we go to our settings folder, let's say create a new file here, let's say um a password or so.tsx. Now, this route is of course going to be a child of settings. If we go to settings / password, the settings route is going to be rendered. It's going to be matched. Uh, sorry, I think I think I have a typo here in password. Let's rename this to password like so.
(36:02) So, what if we would like to have this uh settings/password route not a child to settings? So, we don't have to have this text and this navigation and so on. Uh, we need it to be a child to the root route. What we can do is instead of having this here, we can create a new folder uh sorry folder not of file and this folder sorry is going to be called settings and then underscore right by having that we can move password to this folder and this way uh the URL for this route is going to be settings/p password. This underscore is going to be ignored. But now it is not going to be a child to this settings
(36:52) route. So as you can see we don't have the navigation. We don't have the text for uh / settings and so on. If we take a look maybe at the tree settings/ password is now its own route. It is not a child to settings. So this is how we can do that by just adding this underscore in order to match a certain URL without having to be um a direct child of this settings route.
(37:22) What if we would like to have a parent route that can act as a common layout for some routes? However, we don't need this parent layout to have a path. So for example, in our case, we have this settings parent which can act as a layout for any route that is a child to it.
(37:42) So if you go to settings/p payments settings/profile, we're going to have this settings route displayed here rendered and we can use it as a layout to display a navigation for example uh as we have here. But what if we would like to have that layout but without this path without having to go to settings/ something in 10stack router we can have bothless layouts as well.
(38:03) So let's say we need to maybe go back to uh this approach, this one where we're going to have our root layout and we're going to have settings as its own uh route and settings/ payment as its own route, setting slash profile as its own route as well. However, we need all of these routes to have a common layout without having a path.
(38:22) Right? So we need to have some sort of a layout here and then we can have our routes. Uh so settings settings/ payments settings/profile and so on. However, this parent here we don't need it to have a path. We just needed to act as a layout for common UI elements like navigation for example. To do so we can uh use a special syntax in our folder.
(38:50) So let's go in here and instead of this folder being named as settings, we can rename it. And in order to make this parent not have a path, we just add an underscore. And then we add a unique identifier for our pathless layout. Let's maybe make it more clear and call this settings layout like so. And what we need to do is we need to keep uh this route.tsx as it is.
(39:16) Right? So let's also close this file. So now we are going to have errors because we don't have these paths anymore. But we're going to fix that in a moment. So now inside of this settings layout and then route, this is going to act as our layout for any route that we're going to put inside of this folder.
(39:41) So now as you can see here in our tree, we have uh this layout as a parent. However, it does not have a path. So we can directly go to payment. We can directly go to profile without settings. But as you can see, this parent layout is going to be matched and it is going to be displayed here. Let's now make it more clear that this is a postless layout and not uh a parent route like so.
(40:05) So, we're going to have our navigation. Uh we're going to have our text here, but now we need to fix these links because now we don't have / settings. We just have payment and profile like so. And this should still work like so. And of course, we can still make the URL / settings/ something and still use this layout. How? By uh let's actually get back this URL to SL settings/ something.
(40:34) And simply inside of our layout, we can create a new folder settings and move payment and profile inside of settings like so. Now uh we shouldn't have errors in our uh route here in our route. TSX inside of settings layout. We shouldn't have errors because now we have settings/p payment and settings / profile.
(41:01) Now we can uh if we take a look at our tree, we're going to have this layout which is a parent to settings/p payment and settings/profile. What if we would like to have slash settings as well as a route that uses this pathless layout as well? Remember, in order to do that, we can create an index file inside of settings like so. So, index.tsx. And now we're going to have settings matched as well.
(41:32) And it is going to be a child to our settings layout here. So now we are able to achieve uh this approach. However, where settings and settings/ payment and settings/ profile all have a common layout that does not have a path. All right, great. Uh let's now make it maybe do one final thing for this in our layout.
(41:59) So remember our layout is going to live in route.tsx inside of the layout. Let's make a link uh that goes to SL settings. So in here, let's maybe uh duplicate one of these and make it go to SL settings directly. And uh let's make it say general settings or so. Right? When we have this, it is going to work. However, if we go to payment, this is going to still be active.
(42:30) Right? So this happens by default. The active link is going to be considered active if it is matched or if so if settings exactly is matched or settings/ something is matched as well. However, in our case we don't need to have that. So in here we can pass exact. Oh sorry not here in active options we can pass exact and set it to true.
(42:59) And this is going to make this link active only when settings is exactly matched, not settings/ something. So this is going to fix it. And by the way, we can set this option for a specific link or we can set it globally as well when we define our router. Sometimes in your folder, you might need to create some folder here to maybe put inside of it some components. However, you don't need to create a route for this folder.
(43:25) So, for example, let's say inside of this settings layout, we need to put a folder to put inside of it components related to settings. Of course, you can put it outside of the routes folder in a shared component, but maybe you prefer to put components related to settings inside of the settings folder or settings layout.
(43:43) If you create a folder here and call it components, this is going to create a route. So in order to create a folder that is going to be ignored by tanstack router, you just add a minus or a dash before uh the folder name. So if you add dash components like so and then inside of it let's say uh add a component called navigation or so.tsx. Now this is going to be completely ignored by tanstack.
(44:10) If you take a look at our tree here, we're not going to have anything related to this folder. Now we can put uh let's say um in our route layout maybe we need to move this navigation to this component. So let's move it from here. Uh create a new component. Put this here. Import our stuff. So import link from tstack router. Let's remove this as well.
(44:40) Now we have this component here and we can just import it here. So nav from our components folder like so. And this one is ignored. So we are not going to have components/nav route. And now if you save this, we're going to get the same. But now we have our um layout more organized where we have a folder for components and we have our navigation inside of here.
(45:05) So I would like to also mention one final thing related to the folder structure and the naming conventions that we have here which is groups. So in your folder you can have in your routes folder of course you can have folders wrapped in brackets or parenthesis and these folders are not going to affect the URL in any way.
(45:26) They are purely organizational uh if you would like to just organize your routes into different folders. However, we're not going to have app in our URL. It's not going to have any effect. So, I'm not going to try it, but uh just keep this in mind if you'd like to use it in your project.
(45:47) In addition to being able to nest routes by creating folders and putting routes inside of folders and so on, we can also have this routes folder completely flat without any folder nesting by following a certain uh way to name our files when we create our routes.
(46:06) So, what I'm going to do is I'm going to maybe completely redo everything that we've done regarding these nested routes, but without any nesting, without nesting any folders. Our routes folder is going to be completely flat. So, what I'm going to do is I'm just maybe going to create a temp folder inside of our source folder and move our nested stuff. So move settings underscore here and also move this settings layout inside of this temp folder as well.
(46:31) So now we don't have any nesting inside of routes and let's try to recreate these folders but without uh nesting any folders. So in order to do that we use dot in order to nest layouts and routes. So in here for example we need to define our layout settings layout.
(46:51) So what we can do is in here we can create a file underscore settings layout. And notice that this is a file and not a folder. So we don't need to create a route.tsx inside of it. We're just going to have that. And this is going to be our layout. We can just copy the stuff that we had before in route.tsx and uh maybe just copy this div and put it here instead.
(47:18) So we had this uh let's import outlet and we had this nav component that was defined in this components folder. Let's actually move this components folder now inside of our rows folder like so since we are not going to have this underscore settings layout folder anymore. And now we can just import nav from this folder like so. So here we have our settings uh layout as a file without any folder and any route uh tsx file.
(47:50) So now what if we would like to create a route that is a child to this layout. Now that we don't have a folder what we can do is we can use dot. So we can create a new file like so. So remember we had uh inside of this layout we had our settings route and we also had settings/profile and settings/p payment.
(48:09) So how can we do that now without any folders? We can create settings uh underscore settings layout and then dot and then settings dot index to create of course tsx to create the settings index route. So remember we had a folder settings layout and then settings and then index to convert that into a flat route. We just create a file settings layout settings index.
(48:35) And now we can go to this old index file. Uh or we actually didn't do anything here. So let's maybe just keep it like so. And now if we save this we should be able to visit / settings. If we take a look at our tree, we have settings layout and as a child we have settings. Let's now do settings uh / payment and settings/profile which is going to be exactly similar but instead of index here we're going to have dot something else.
(49:06) So let's do actually quickly I'm going to copy this uh name from here and inside of routes create a new file paste. Instead of index, let's do profile. And uh let's do another one for payment. And uh now as you can see we have settings layout. And as a child we have our settings payment, settings profile and settings index. So this should be it for uh this settings layout folder.
(49:36) We have moved everything into flat files here. Uh it looks like it's not working. We should have our navigation here uh to navigate between different settings pages. I think maybe we just need to maybe restart our server or so. Let's try to do that. Uh still not working. Oh, actually, sorry. Uh I have a typo here.
(49:59) This should be settings and not setting. And uh yeah, this should work. So now everything is working as before. But now uh we don't have any nesting inside of our routes folder. Everything is flat. Finally, remember we had the settings underscore folder and then we had password.
(50:22) In order to make password not use the settings uh layout, we can do that as well in a flat way by simply creating a file called settings underscore and then dot password.tsx. This way. If we take a look at our dev tools, we're going to have settings/p password, but it is not a child to the settings layout. And if we visit this route where we're not going to have the navigation and so on.
(50:53) So now everything that we've done, we can now remove this temp folder and everything that we've done using the folder we can do using uh this flat way as well. We can also use both ways together. So we can have a folder inside of it. We can use this dot uh syntax as well. So of course this is up to your preference.
(51:14) Maybe you are okay with some nesting but maybe you don't want to go very deep in nesting folders. So you can create maybe some folders but then you can use this dot notation as well. By the way I just uh realized something that uh in our case uh the underscore after settings here would not matter uh because settings is not the parent.
(51:35) So if we actually remove this underscore uh sorry rename remove this underscore this will not make a difference because settings is not a parent anyways. Remember we are not using settings as a layout. Settings is uh is its own separate route here. We have an index for it. So this will not make a difference.
(51:54) We can still visit uh settings/p password and it is still going to not be a child of this layout of course uh because we don't have settings layout in the folder name. We will need this underscore however if we had settings as a parent. So if we maybe rename this index uh remove this index from our name and maybe go in here and in here maybe uh just display an outlet so that settings can be apparent to any child like so and also let's assume uh this settings password is also using this settings layout.
(52:33) So let's rename this like so settings layout settings password. so on. Now, as you can see, we have settings layout and then we have settings as a parent and it has a password, payment, profile and so on. If we need password in this case to not use the settings as a layout. Now, in this case the underscore will be helpful.
(52:55) So, here we can rename this uh sorry here rename this and put the underscore like so. And now as you can see now settings is only apparent to payment and profile. However, settings/p password is not a child of settings. So I just needed to clarify that to avoid any confusion. Of course in many situations in your applications you are going to need to have routes with dynamic parameters.
(53:27) So we might have for example a blog or so and our URL should be maybe posts/ some ID and this id is a dynamic parameter. It is not something that we know. So in this case we also use a special syntax when we name our files and folders. For the rest of uh this video I think I'm going to carry on with this flat way of doing things.
(53:51) However, of course as you know anything that we can do using this flat way can be done in folders as well. All right. So let's create uh let's say we need to have um some routes. So let's say we have our root route here and we need to create three new routes. One for posts is going to be a list of posts. So we're going to have here posts and then we need to have posts/ ID.
(54:16) However, keep in mind that posts/ ID should be a separate route and not a child to posts. So it's going to look like so post/ ID. So let's say this is posts. This is posts / id. And then let's say we need a route to edit a post. So we need our URL to be posts / id/edit.
(54:38) However, also keep in mind that when we create this edit route, we don't need it to be a child to post/ id. We don't need it to be here. However, we need it to also be its own route. Uh posts id/edit because it's going to contain completely different things. it is not going to be a child to post / id. So we will not have this route. Right? So let's see how can we do that.
(55:02) We should already know uh everything we need in order to create this except of course how to create dynamic routes which we're going to see now. So let's first create the slash uh posts route which is going to contain maybe a list of posts. Remember we need this to not be apparent to anything. So to do that we just create a new file and call it posts.index.tsx.
(55:26) By adding this index post is not going to be apparent. It is only going to be matched if our URL is posts exactly not posts uh/ something. We already know that right? So now we have this route and of course by default uh we have some text generated here uh hello posts.
(55:47) Now let's say we need to create posts/ id. In order to create a dynamic route we use dollar sign. So create a new file and then let's say posts and then to have a dynamic parameter we use dollar sign and give it any name. So let's say post ID or so and then uh tsx. And of course if you uh are using the folder way you can create a folder called posts inside of it a file called dollar sign post id.tsx.
(56:12) Right. So now we can visit U posts/ something and we're going to get this route. Now finally let's create our final one. So as we've mentioned we need to have posts uh post/ id/edit right. So we can simply go in here create a new file post dot and then dollar sign post id and then ededit.tsx. However, if we take a look at our dev tools, this edit route is going to be a child to posts/ ID. And as we've mentioned, we need these to be separate routes.
(56:53) So remember how to do that to make edit not use posts/post ID as a parent. We can do it actually in a couple of ways. We can rename this to posts.post ID.index like so. And now this is going to be its own route. If we take a look, we're going to have three separate routes. Posts, post ID, and then post ID/edit.
(57:20) However, we also have another way. So, let's get get this back without index. We have another way using this underscore syntax. So, remember in order to make a child route not use its parent as a layout, we can use underscore, right? So in here in this edit route we can make this route not use posts as a parent by renaming this and adding underscore here after posts.
(57:53) And now as you can see we get the same result posts posts/ost ID/edit and then post uh / id right. So we have these uh two approaches of doing this. Of course, now uh let's say we are visiting some post. So post/ some id in our route. Of course, we are going to need to use this ID somehow. So later we're going to discuss uh load functions or loader functions.
(58:19) This is probably the place that you are going to need to access this ID in because this is where you are going to load your data. However, if you need to access this id in your component as well, you can go here uh in post uh / post id or the edit one as well and we can do something. So in here we have this route. In this route we have a bunch of hooks that we can access.
(58:42) So we can create a new constant here and then route dot use uh params sorry use params. In here we're going to have access to the post ID and it's going to be uh we have auto completion here. is going to be type save and everything. So we have post ID here. Let's maybe put it in a new line. Let's say post ID and put it here. So now we have our post ID.
(59:08) Let's assume uh this component maybe lives in a different file. So we're not going to have access to this route. How can we access use params in this case? So let's assume maybe in our components folder. Uh let's say we have a component for the post. Let's call it post.tsx.
(59:29) And let's actually copy uh our stuff from here. So let's copy that and create a new component and just put this. And now we need to access post ID in a separate component and then use this component here. So let's return this component that we defined like so. So of course we can pass maybe post ID as a prop here. However, there is an easier way to do that. So, let's remove this.
(59:55) You might think uh we can maybe import route this route. We can import it from this file into this file and then use the hook. However, this is not the recommended way to do it. The recommended way to do it is to use a function called get route API. So, let's create a constant here and we can call a function get route API.
(1:00:19) In this function, we can pass the route that we need to get the API for the hooks of this route. In our case, we need this one posts uh/post id. We're going to get from this an object that contains the hooks for this route. So, we can access use params like so. And then we can simply get uh from use params our post ID. And as you can see, everything is type safe. We have auto completion for everything.
(1:00:48) And as you can see, this is uh this is still going to work as well. Right. Finally, let's see how can we link to uh parameters with dynamic segments. So let's maybe go to /osts and uh later we're going to have a list of posts here. But let's from now just add some dummy links. So let's go to this route which is posts index.
(1:01:10) And let's say we need to link to some posts in here. Of course, we still use this link component and let's say maybe go to post or so. However, when we specify our dynamic parameters, we do it in a certain way. So, into we don't put um posts/ the ID itself.
(1:01:35) We put posts slash the dollar sign post ID which is the post to our folder. And to specify this dynamic parameter and do it in a type safe way, we pass it here in a separate prop which is params. In params, we're going to get type safety. So if we type P here, we are going to get post ID. And if we maybe pass it as a number, we're going to get an error. We should pass it as a string.
(1:01:57) If we maybe have some typo here in our parameter name, we're going to get an error as well. And so on. By doing this, we're going to get this link. go to post. If we click on it, it should go to this post. We have another way as well. So, let's go back and let's create another link. Or actually, let's maybe duplicate this one. And instead of passing parameters as an object, we can also pass it as a function.
(1:02:24) So, in here we can get our previous parameters and then we can return an object with our new parameters. So, can return an object. Maybe we need to keep let's say we have multiple dynamic parameters. So let's say we have uh parameter one/parameter 2/ameter 3 and so on and we only need to update one of them and maintain the others.
(1:02:47) This is going to be uh perfect in this situation. In our case, of course, this will not make a difference since we have only one dynamic parameter. If we have multiple, we can keep the previous ones and update one. In our case, we have post ID and we can pass it here as well. So, this link should work as well. So, now we know how to have a dynamic parameter in our URL.
(1:03:14) However, what we've seen is having a dynamic parameter of only one segment. So, in here, for example, we had our posts/ ID. We only have one segment here that is dynamic. Sometimes, however, we might have multiple segments that are dynamic. So for example, we might have maybe a route that is file slash a path to a file. So in this case we might have maybe x /y/ z dot something and so on.
(1:03:42) In this case this whole part is dynamic and now we have multiple segments here. So we have x and y and zed and so on. And we need our dynamic segment to be all of that and not only this x part that comes after the file. So similar to other routers that you might have used before in tan stack router we also have a way to catch multiple segments in a URL. So let's see how we can do that.
(1:04:05) So what we can do is we can go uh in here and let's say uh let's create this route file/ something. However this something is multiple segments and not just one segment. So in routes let's create a new file. Let's call it file and then dot and then to catch a lot of segments we use dollar sign without any name here.
(1:04:24) If we give a name here then this parameter is only going to be one segment. But if we need to catch multiple segments we just use dollar sign like so and then just simply tsx. Now in here we're going to be able to get our parameter and use it in this way. So remember we have used the route dot use params.
(1:04:49) So route use params uh hook to get our dynamic parameter. We're going to use this same hook. However, to get uh this whole segment x/y/z and so on, anything that comes after file, we can access this using underscore splat like so. So let's maybe add a new line here and let's say file path and let's display this. Now if you save this and let's go to this route right now as you can see we get our file path and we have captured everything after file x/y/z.
(1:05:29) txt right and of course we can combine this with other parameters as well. So let's say our route our URL is going to be file and then we're not going to have the path directly after file. Maybe we're going to have maybe some ID for the file uh for the file first and then the path and we need to capture this in a separate parameter and then capture the rest uh in this split parameter that we get here. Sorry. So how can we do that? Simply we can create another parameter.
(1:06:00) So before the dollar sign, we're going to have an ID for the file. So we can simply rename this and then file dot dollar sign and then give a name to the ID parameter that we're going to have after file. So file ID for example and then dot dollar sign which is going to capture everything after this ID.
(1:06:22) So if we save this and go back here and uh let's maybe visit a route that is maybe file slash some id /xyz.txt and so on. Now as you can see we still get x/y/z.txt as the file path and we don't get anything from this ID that we put here. If we need to access this ID this is going to be a separate parameter that we can get here. file ID.
(1:06:55) So let's maybe display it as well file ID and then let's put this and we get this in a separate parameter. We can also have for example prefixes and suffixes before our um parameters. So let's say for example before our ID we're going to have some prefix. Let's say file dash and then the ID. And we need to capture only this part as our ID parameter.
(1:07:21) Now, of course, if we visit this now, we're going to get file dash as a part of our ID, but we don't need that. We only need to capture this part. So, to do that, we can rename this file and then put file dash here and then put our parameter in curly brackets like so. Now if we save this go back here as you can see we only get this part as our ID even though we have file dash in our URL.
(1:07:55) Let's maybe try one final thing. Let's say uh we need our file path to be x/yz without the txt part. So let's say um our file is always going to be txt for example and we only need to get this part without txt. So we can make txt part of our file name and only make this part as our parameter our dynamic parameter. So can simply go here and uh let's rename this again.
(1:08:26) Now in this case we need to capture anything before txt. However, if we put dot here, this is going to uh indicate that this is a child route. But we don't need that. We only need to have .txt as a suffix to whatever comes after this dollar sign. So instead of just dot, we put dot in square brackets like so. And then txt.
(1:08:51) And then we also need to put our dollar sign in curly brackets like so. This way anything after the file ID and before txt is going to be captured in this dollar sign which we can access using this underscoreplat parameter. So if we save this as you can see uh we get our file path without txt and we get our ID normally and of course as you can see uh you can go crazy with this. You can do a lot of dynamic stuff here.
(1:09:21) Something else that you maybe have seen in other routers as well is the ability to have uh optional parameters. So let's say we need to have a route uh for example for an archive of something. So we're going to need to create a route that is going to be /archive. And for this archive for example, we can you can visit archive itself and we're going to get everything in this archive or we can narrow it down by passing a date here for example.
(1:09:50) And we can narrow it down even more by passing maybe a month and then a day and so on. But all of these are optional. And also let's say we have multiple languages. So before archive we can have a language like so. But this is optional as well. If we don't pass it we're going to get a default language.
(1:10:11) So let's maybe visit this route which is of course going to be not found for now. Let's see how can we create it here in our routes folder. So in order to create optional parameters we do it this way. So we use dollar sign and then the parameter name normally. However to make it optional we put it in curly brackets and then put minus before the parameter.
(1:10:31) So minus dollar sign and then for this first one we need it to be the language. So let's say local and then slash archive and then slash and then we have the rest of our optional parameters which is year. So minus dollar sign year and then we also have the month and finally we have the day as well. And of course don't forget the uh tsx.
(1:10:56) However uh I did it so that it will create folders inside of each other. Let's do it also using the flat way. So instead of uh creating folders, let's replace these slashes with dots instead. Uh so that we can just carry on with the flat way that we've been using. But of course, you can also do it with folders. By creating this, we're going to uh our route is going to be matched now.
(1:11:19) And uh we can see in our dev tools that we have this route with our optional parameters. And we can simply access our optional parameters in our route using the uh use params hook as well. So in our route dot use params hook route use params we're going to get all of our parameters the local the year the day and the month. Over notice that for the type since they are optional they are going to be string or undefined.
(1:11:51) So let's display these here. Maybe I'm going to put this div to display our parameters. And now if we save, we're going to get our local year, month, and day. But we don't have to pass all of these. We can maybe remove the language from the URL. We're going to get undefined. We can remove maybe the day.
(1:12:10) We're going to get undefined here, but the route is still going to be matched. And of course, when we use these parameters, we're going to need to check if they exist or not before we maybe do some action. And now to navigate to this route and pass optional parameters. We also simply use the link uh URL.
(1:12:34) Let's maybe go to our home route which is inside of index and then uh add a link here and try to navigate to our route with optional parameters. So let's say go to archive and then inside of two we're going to need to oh sorry let's import link first. And inside of two, we're going to need to put our route, which is this one.
(1:12:59) And then we can simply specify our parameters using the params prop here. But we don't have to put all of our parameters since they are optional. So we can maybe put uh just the language for example. If we do so, this is going to take us to uh the language/archchive without any year or month or day. Of course, we can maybe add a year.
(1:13:22) Now sorry this has to be a string as well. And now this link is going to take us to frrarchchives slash the year and so on. We can also pass parameters uh as we've seen before as a function if we would like to maybe maintain our existing parameters and only update uh one parameter. And this can be very useful in our case to maybe create a language switcher.
(1:13:47) So let's say uh let's maybe go to a URL which is language archive slash month sorry month/day for example and now let's say we need to have here in this route let's go back to this route we need to have a way to switch our languages however without affecting the currently selected date. So we only need to change this fr parameter.
(1:14:11) So this can be easily done since we can pass a function to params uh to the params prop instead of just um an object. So let's maybe have uh here let's define a couple of available languages and let's loop through these languages and display a link that is going to take us to the existing URL but only update the language.
(1:14:32) So in here, let's maybe add a div. And inside of here, I'm just going to display it uh to add the background, color, padding, and so on. And then inside of here, I'm going to loop through my languages. So languages map. And uh in this array, we have the code and the name. So in here, let's dstructure our code and our name.
(1:14:54) And then let's return a link component. So let's import link like so. And uh let's put maybe the name of the language. Oh, sorry. The name of the language in here. And of course, let's add a key as well. Maybe let's add the code as a key. If we save this, we're going to get this. But now let's make this link go to our route, which is this one.
(1:15:22) And then let's also pass our parameters. And now let's pass it as a function instead in order to maintain our previous parameters but only update the language. So in previous uh we're going to get previous here and we can return an object and maintain our previous parameters and then post the new local.
(1:15:42) The new local let's say if it is English we don't need to post it. Uh we don't need to add it to the URL since this is maybe our default language. So let's check here if our language is English. If we don't need to pass it, we can explicitly specify this to be undefined. Otherwise, just pass the code like so.
(1:16:03) I'm also going to add this class name here to highlight the currently selected language. So, if the language is equals to the current code or if the language is undefined and the current code is English, then we need to highlight English. So, we are going to make our font bold in these cases. So, now we have u French highlighted here.
(1:16:24) since our local is French. And now we can switch. And notice that when we chose English in our URL, we don't have anything before archive since this is what we've done in our code. And our local is undefined. And um the rest of our optional parameters were maintained since we are passing this function here and maintaining our previous parameters.
(1:16:45) And we can go to other languages as well. And this is going to update our URL. Search parameters are a great way to store the state of your application. So let's say you have an application that maybe has a lot of um filtering, pagionation, sorting and so on. If you store this information, the information regarding the current page for example, uh the current filters and so on in the URL.
(1:17:14) This means that you can easily maybe share this URL or bookmark it or open it in a new tab without losing the state since the state lives in the URL. Unlike when you for example store your state uh or store these information in a react state once you navigate away from the page or refresh or anything like that you are going to lose this state.
(1:17:33) So if you have an application that maybe relies heavily on search parameters to do things like filtering pagionation sorting and so on. It is important to be able to manage search parameters easily. Being able to validate search parameters, have type safety for search parameters when you manipulate them and also be able to store complex data uh like arrays and objects for example in search parameters and not just simple strings.
(1:17:58) Tanstack router allows us to do all of that pretty easily. So let's see how can we manage search parameters in 10 stack router. So I'm going to assume we have a new route here. Uh let's say maybe for products. So products.index.tsx. And maybe in here we're going to have a list of products or so. And we're going to have some filters to filter our products. Pagionation sorting and so on.
(1:18:23) So let's create this route. And now we can visit this route by going to slash products. And now let's say uh in our homepage for example. So let's go to our index and let's say in here we're going to have a link that is going to take us to the products route. So let's say products with filters and let's say we need to include some filters in our search parameters.
(1:18:50) So we're just simply going to go to our products route and then to add some search parameters we simply add a search uh prop here and then in an object put our parameters. So in here I'm going to put some items and as we mentioned intense stack router we can pass anything here. We can pass strings. So sort by price for example. We can pass arrays. Maybe filter by product type and pass an array here.
(1:19:16) We can have a pageionation which can be an object with our page and page size. We can have another array filtering by colors. We can have a boolean as well and so on. Now, if we save this, go to our homepage and click on this link, which is uh this one, products with filters. Let's actually add a new line here. We're going to go to a link with all of our uh all of our stuff included, all of our search parameters.
(1:19:50) So, as you can see here, we have products and then we have our sort by and our encoded array and object and so on. So in our search parameters we can pass any JSON serializable data like as we've seen here arrays and objects and so on and then stack router is going to serialize it in the URL as we see here and when we use it in our route it is going to des serialize it and get it back to this state here uh where we're going to have an object with our strings arrays and objects and so on.
(1:20:19) If you take a look at our dev tools here in here, we're going to find our search parameters and as you can see, uh I'm not sure if we can move this like so. As you can see, we have our search parameters here. We have our sort by price. We have our arrays pagination object and so on. I guess we just need to Yeah, here we go.
(1:20:44) And now of course we can access our search parameters in our component or in load functions uh that we're going to discuss later of course. So let's try in our component to access our search parameters. And this can be done by accessing in our route uh another hook which is called use search. So use search like so. And uh from here we can get our search parameters.
(1:21:09) Let's actually try to log these and we should get the same stuff that we uh that we've seen in the dev tools. We have our object containing our uh colors pagination product type and so on. And of course now we can use this information in our component to maybe highlight the currently selected filters and so on.
(1:21:28) But as you can see when we created this link in our homepage to link to the products uh route we did not get any type safety when we specified our search parameters here. We can just pass anything and we're not going to get any errors. We can maybe set this to be a boolean. We're not going to get an error and so on.
(1:21:47) So let's now see how can we validate and add type safety to our search parameters. So in our component the component where we pass our search parameters which in our case the products component in here we can pass a function called validate search. In validate search we're going to get the search parameters that we are passing in our URL. So this is going to be an object. So we can give it a type of record where the key is going to be a string.
(1:22:13) The value is going to be unknown. Right? And in this function we can return an object where this object is going to contain our validated and typed search parameters. So what we receive here as an argument is whatever we pass to our URL which can be any untyped unvalidated data. And in this function we're going to take this validated and give it a type.
(1:22:41) So for example let's maybe do it for now for sort by. So let's say sort by uh needs to be a string. So in here we can pass search do sort by as string give it a type of string and maybe if it does not exist let's pass an empty string. So now by having that we're going to get errors because we are passing stuff that we are not specifying here. So let's maybe remove these for now.
(1:23:07) Maybe comment these. And now we're not getting an error because we are passing sort by as a string. If we maybe pass it as a boolean, we're going to get an error because we specified this to be a string here. And now this link is still going to work. But of course, we're only going to get uh the sort by parameter here.
(1:23:27) However, it is recommended, especially if you maybe have a lot of uh search parameters in your component, to use a validation library like Zod. So in case you're not familiar, Zot is a library that can help us validate and type data. By defining a schema. So we can define a schema like so.
(1:23:48) We have an object with a key of name that has a type of string and so on. And using this schema, we can validate objects. In our case, we need to validate whatever we will pass in our search parameters. So let's see how can we use ZOD with tenstack router. And by the way, 10stack router also supports other validation libraries as well. But let's for this example use zod.
(1:24:07) And to use zod with tensstack router, we need to install this package uh tense stack and then zod adapter. This is going to install uh this adapter and also zod itself as well. So let's install that uh sorry and let's see now how can we use it.
(1:24:30) So what we need to do uh is we need to define a schema that is going to contain everything that we are going to have in our search parameters. So let's define a schema and inside of it define the types for these things sort by product type pagination and so on. So so I'm going to create a constant here. Let's call it maybe product search params schema.
(1:24:52) And we need to import zed from zod like so. Of course you you can call it anything. It is just usually named as Z here and then we need to have an object in our schema. So an object with these things. So first of all sort by and uh in here we can maybe pass it as a string.
(1:25:17) However, probably in our application we're going to be able to sort by certain things like price um popularity maybe stuff like that. It's going to be predefined things not just any string. So in Zod we can have an enum type. So zed enum. And in here we can pass things in an array. So let's say maybe sort by newest. Let's maybe add another one. Oldest. Let's maybe say uh price and so on. So this is basically the idea. I'm pretty sure you are already familiar with zod.
(1:25:45) So what I'm going to do is I'm going to put the rest of our schema here and let's go through it quickly. So for product type uh we have this as an array. Let's also pass it as an enum for the type and let's maybe have an enum of shoes and t-shirts for example and we can have a default as well. Uh so let's maybe default it to shoes.
(1:26:06) And by having a default here if we don't pass this in our URL uh this is going to be used. We're going to see that in a moment for pagionation. Remember we can have an object with page and page size which are numbers. So here we have Z dot object page page size and they are numbers and they have a default value as well 1 and 10 and then colors and uh an array and this array can only have these things.
(1:26:33) So an enum red, blue and green and uh we can make this optional. I'm making this optional by passing optional here and then sale uh and this is a boolean and let's also default it to true. So you can put whatever you like here. But now that we have a schema, let's see how can we use it. So in this validate search function, instead of passing a function and doing uh the typing and the default values on our own, we can just remove this.
(1:27:01) Now, now that we have the types defined here and pass um zod validator, which we can import from this package uh which we installed, right? And then pass it the schema. So we called it I guess yeah products search param schema. So we can pass this here and just by having that now let's in our URL let's maybe try to not pass anything in this search uh prop and we're going to get an error.
(1:27:34) Why are we getting an error? Because in here we are specifying sort by to be an enum but we're not having a default value for it and we're not marking this as optional. similar to what we're doing here. So sort by, we have to pass it. So if we pass sort by, we're not going to get any errors. And now if we navigate to this uh link. So let's go to home and then navigate to this.
(1:27:57) As you can see in our URL, we're not just going to get sort by. However, we're going to get the defaults of the other uh stuff that we have in our search parameters as well. So if you take a look at our logs here, remember we are in our component, we are logging our search parameters in our URL, we're going to get whatever we passed in sort by, but also we're going to get uh so remember in product type, we had a default of shoes. So we get this here.
(1:28:24) Also in pagionation, we had default values for uh page and page size. So we get these here as well. And also in sale we default uh we defaulted this to true so we get it here right colors however remember we made it optional so we might not have it here the type for colors is going to be uh an array or undefined.
(1:28:49) So by making this optional it is not guaranteed that we're going to get it in our search parameters. So if we take a look in our component at the type for our search parameters in colors we have undefined here. However, for anything that we have uh that are that is not optional or that we have defaults for we are not going to have undefined.
(1:29:13) It's going to guaranteed uh to exist in this search object even if we do not pass it here explicitly. Let's also maybe try to pass something uh outside of our enums. Remember here we specified newest, oldest, and price. If we pass something else, we're going to get a TypeScript error. And similarly here, um, if we pass, uh, I guess we have a problem here.
(1:29:36) Oh, so yeah, this is an enum, not an array of enums. So we need to either pass shoes or t-shirts. If we pass something else, we're going to get an error. In pagionation, for example, if we pass something wrong here, we should get an error and so on. But now what if someone edited maybe this URL and put wrong types here.
(1:30:01) So when we navigate inside of our application, if we pass something wrong, we're going to get an error. What if someone uh has a link that contains some wrong information? How are we going to deal with that? So let's say for example uh in sort by here we pass something wrong, something that is not price or oldest or newest. So I'm going to type anything here.
(1:30:20) And now as you can see we're going to get an error. So we can customize this error page. We're going to talk more later about error handling. But we can basically uh sorry not in here in our products route we can uh simply pass an error component here. And in here we can just pass a function and return some let's say maybe for now P tag. Let's say error.
(1:30:46) So now we're going to get this. So you can choose to do that display an error if if you have a wrong wrong data in your search parameters or maybe it would be a better experience to maybe if you have something wrong in one of your source parameters just fall back to a default value.
(1:31:05) So let's see how can we also do that. So let's maybe try it uh with the sort by one only as an example but you can do that for all the other attributes as well. So in zod we can have a catch here dot catch so that if we had any type error here in our data we can provide a default value. So let's say newest for example. Now if we uh let's also open our uh console.
(1:31:37) If we save this and refresh we're not going to get an error. And in our search parameters, we're going to get newest in sort by. And also, of course, if you take a look at the URL, it is going to be changed to newest. However, by doing it this way, we're going to lose the type information uh in our link.
(1:32:01) So, for example, now if we pass anything here, we're not going to get a type error because the type for this is going to be unknown. So to fix this problem, Tstack router provides us with a way to provide a fallback while maintaining the type information. So instead of using cache uh catch here, let's remove this. And what we can do is we can import a function called fallback from the Z adapter then stack Z adapter and wrap our enum with it.
(1:32:27) And of course it doesn't have to be an enum. We can wrap any type with it. So let's wrap this with the fallback function like so. And then as a second argument to fall back. So in here we can pass a fallback value. Let's say newest. And now if we save this and go back here, as you can see now the type is maintained. If we have something wrong here, we're going to get an error.
(1:32:51) And if we in our URL pass something wrong in sort by, it is going to fall back to newest. And of course uh as we've done in one of our um parameters the sale one we can also still provide a default value if we don't pass sort by. So when we use fallback we can do this after fallback after closing our fallback function in here we can still provide a default.
(1:33:18) So we can default to newest for uh for example. And now if we don't pass newest let's maybe remove it from our URL like so. And uh if we take a look uh somewhere in our URL, we should have it. So let's go here. As you can see, we get sort by newest even though we did not uh we did not pass it in our URL.
(1:33:42) And of course, I've done this only for this parameter, but you can do the same for the rest as well. Provide the fallback in case uh something is wrong with the URL. So this is how we can um validate and type our search parameters in tenstack query. One thing that you can also do now I'm not going to do it but you can take a look at that if you would like.
(1:34:08) This is a little bit advanced which is customizing how the search parameters are serialized. So as we've mentioned when we pass a a URL here with search parameters it is going to be serialized in this URL and then it is going to be parsed when you use it in your load function or components and so on.
(1:34:29) You can customize how this process happens how your URL is serialized and parsed and so on. By default 10stack router parses and serializes your URL using JSON stringify and JSON.parse. However, you can customize this by passing a couple of functions parse search and stringify search and doing custom stuff here. So, we have some examples here. Uh maybe using base 64. You can pass custom functions here.
(1:34:55) You have other examples as well using query string library. You can also use it with stringify search and parse search. However, in most cases, I guess the default behavior is maybe going to be enough. But just know that this exists uh in case you are in a situation where you need to customize this behavior.
(1:35:16) But now something that you are probably going to have uh in your application when you have a lot of search parameters is uh you're going to probably have a component where where you are going to be able to uh change your filters or allow users to change the filters. And in this case, we're going to need to somehow update certain search parameters while maintaining the existing search parameters. We've already seen how to do that with URL parameters by passing a function to the params um prop here.
(1:35:47) Instead of just an object, we can do the same with search parameters as well. We can pass a function where you are going to receive your previous search parameters and you can uh return an updated object. However, before trying that, let's maybe u mention some more information about this link component because we haven't yet discussed everything about this link component.
(1:36:10) So, let's maybe discuss a couple of stuff about it and then get back to this search prop and try to pass a function instead of just an object. So far in our links, we've been using in this two prop the absolute path to a route when we need to navigate to a certain route. So, in here, for example, we need to navigate to the products route.
(1:36:30) So in here we put the full path to the products route. And if we if this was nested somehow, we're going to need to put the full path like so. We can either do it like so by hard coding the route name and if we have any typo, we're going to get a type error. Or we can also do it dynamically by importing. So I'm currently in my home route.
(1:36:55) If we need to navigate to the products route, we can import from the products route this route constant that we are exporting here. And in this constant in this object we're going to get a two property where we can dynamically pass our uh the path to our route. So for example I can import route from products index as products route for example. And then in here instead of passing this like so we can make it dynamic by putting products route dot two.
(1:37:22) And this is going to dynamically put the path to the products route. This can maybe be useful if you at some point changed uh the route name which is maybe unlikely but if you do so you will not have to update your links since you are having dynamic uh two prop here.
(1:37:41) What we can also do with this link component is in addition to having absolute paths we can also have relative paths by passing a from prop in addition to the two prop. So in the two prop we can have a path relative to whatever we pass to the from prop. So let's explain more by maybe going to uh some nested route that we have. Let's say the one for editing a post. So posts uh/post id/edit for example.
(1:38:05) And in here let's say we need to uh navigate from posts/post ID/edit back to posts. So of course let's maybe add a new line. Of course we can just simply uh add a link. Let's say all posts. And we can simply add two here and navigate to posts like so. Uh let's import link. And now let's try to visit this route. So posts slash any id /edit. And uh let's save this. And we're going to have this link where we can navigate back to all posts.
(1:38:38) However, what we can also do is uh let's maybe duplicate this link. And we can pass a from prop here. And in from we can either also hardcode um a route that we need to navigate from. So let's say this edit route posts post id edit. Now into in the two prop we can put a path relative to from. So we need to navigate from this route to posts. So we need to go uh up.
(1:39:06) So we can go up like so. And as you can see we also get auto completion. If we put a wrong relative path here we should get a type error as well. So we need to go up one level and then up again and then up again and then go to posts like so. So this is the path to posts relative to uh the posts/post id/edit. And if we just add a new line here and if we try this it should work as well.
(1:39:32) What we can also do is instead of maybe hard coding this route since we are already in this route let's maybe duplicate this link. Let's add a new line. Since we are already in this route and we have our route here, we can get the full path of this route in this route object as well. So instead of hard coding this, we can pass uh in here route dot full path and this is going to be the full path of our uh edit route that we are defining here.
(1:40:02) So this should also work the same. And uh let's say for example we had a a mistake here. Maybe we go up only two levels instead of three. We should get a type error because as we know now everything is type safe in Danstack router. Now let's say we are uh still in the edit route.
(1:40:29) So posts post id edit and maybe we need to have a back button that is going to take us to u the post that we are editing. So by back I don't mean clicking back on the browser and going to the previous link that we were visiting. What I mean is going from edit from the edit route to its parent which is posts / id. So we can also do that using relative path as well. And in this case we don't even have to pass the from. What we can do is we can just add a link.
(1:40:53) Let's say back to post and in here instead of two we can just add dot dot in order to go up one level uh in our route tree. So by having this if we click on back to post we should go to the post/ id route. But if we specified the from here then we're going to navigate to the parent of whatever we pass in from not the parent of the current route.
(1:41:25) So if we for example pass maybe the about route then by putting two dots here we're going to go to the parent of about which should be our home. So, if we go back now to this edit post route and click on back to posts, we're going to go to our home, right? But I'm going to remove this.
(1:41:45) And what we can also do is instead of two dots, we can only add one dot, which means we need to navigate to the same route that we're currently in. So, if I save this and click on back to post, nothing is going to happen. So, I'm going to change this back to two dots. So, how this can be useful navigating to the same route? It can be useful when we need to navigate to the same route that we're currently in and update some search parameters that we have in our uh route.
(1:42:11) So maybe let's go back to the products route and remember in here we had some search parameters. Let's say in our products route we have a component where we can update our filters and so on. So we need to navigate to the same route products but update some search parameters. So we can use dot in order to do that.
(1:42:34) So in here let's maybe add a new link by importing link from tst router. And let's say maybe we need uh we need to have some sort of pagionation where we need to go to the next page. So we need to keep everything that we have in our filters but update this pageionation object with our next page. So remember our pageionation is an object with a page and page size.
(1:42:59) So let's say we need to keep everything but update this page inside of this pageionation object. So let's say go to next page and in here we need to navigate to the same route that we're currently in products. So we can put just a dot. However, in search we can now have a function where we are going to get our previous search parameters and we can uh just return an object with our new search parameters.
(1:43:26) So we need to keep our previous search parameters but only update pagenation sorry pagionation and pagionation is an object. So we need to also keep everything that was in it. So previous dot uh pagenation and only update the page and for the page we need to increment it. So we can just simply uh get the previous page. So previous pagionation page and just add one.
(1:43:55) If pagionation uh does not exist for any reason, maybe we need to fall back to page one. So what we can do is we can just put this in brackets and let's say or one here. And now if we save this, we have this link to go to the next page. And uh let's also maybe open the console in order to see our search parameters. So currently we have pagionation with page one.
(1:44:20) If we click on go to next page, we should have pagionation with page two. Click again page three and so on. And of course, this should be reflected in the URL as well. And if we are loading data based on this page search parameter here, our data should be reloaded and we should fetch our new page as well. So great. Uh one last thing I would like to mention about this link component is you can pass a hash as well.
(1:44:45) So let's go to home maybe uh here and in here as well. And let's maybe for any link that we have um add this hash prop and pass something. So let's say you need to navigate to a section in your page, a div that has an ID, a specific ID. Then we can pass this ID here. Let's say maybe section one. And by doing so is going to add a hash to the URL.
(1:45:14) So, if we click on this link now, as you can see, we're going to have this hash here. Uh, and if we have this uh a div with this ID in our route, we're going to scroll to this part in our page. Of course, currently we don't have it, but you get the idea. Sometimes we would like to navigate to a certain route programmatically without using a link.
(1:45:34) In 10stack router, we can also do that using the use navigate hook. However, make sure to only use this method in situations where you cannot use uh the link in any way. So, for example, let's say maybe in our u let's say in our edit post route as well. So, let's go to slash posts / some id/edit and let's go to this route here as well.
(1:46:02) And let's say maybe we have a form uh and when we submit this form we're going to save our post and when we save our post we need to navigate back to the post. So we are in post/ id/edit. We need to navigate back to posts / id. However we cannot do that using a link. We need to do it when we submit our form after saving our post for example.
(1:46:21) So let's say in here we have a form. Oh sorry a form. And uh let's maybe not have an action. Let's have an onsubmit handler. Onsubmit. And in the form, let's have a button to submit. And now in submit in our event, let's call event.prevent default.
(1:46:47) And let's maybe simulate that we're doing something by adding some fake uh timeout here. Let's also make this async. And after this timeout, let's say our post is now saved and we need to navigate back to the post uh itself. So what we can do is in here we have this hook that we can import. This one is not inside of route. This one we can just import it for for all of our routes.
(1:47:13) So let's create a constant called navigate and then import use navigate from uh 10 stack router like so. In here we can also specify the from in order to be able to navigate to relative paths. So let's say we need to navigate from our current route. So we have access to our route here. So you can pass route the full path. This is uh the route of the edit post route. And now using this navigate object we can navigate or sorry this is actually a function that we can call in order to navigate.
(1:47:45) So in here we can just call this uh navigate function and inside of here we can have the same options that we put in a link. So we have two for example we can also have our search parameters our URL parameters and so on. But let's say two and we need to navigate to post or post id. So of course we can do it like so post id but then we will have to pass uh the id in our parameters like so.
(1:48:10) What we can simply do is just go up one level in our tree. Since we are already in posts/post id/edit we need to go up one level and therefore since we specified from here we can just go up one level like so. By doing so, let's uh submit this form and wait a couple of seconds and we should go back to the post uh / id route.
(1:48:38) One thing I would like to mention is we can access this navigate function uh without using this hook which means we can navigate in our application outside of our component. So we don't have to use this hook. How? By coding. So remember when we defined our router uh which was in main.tsx tsx in here we defined this router. This router already contains the navigate method the navigate function and we can posit uh our stuff and so on to navigate in our router anywhere in our application even outside of our components. So we don't have to use the use navigate hook. I think this is maybe
(1:49:13) something uh you are unlikely going to do but also know that this is possible. Another way to navigate is also using the navigate component. So sometimes in a route you might need to maybe navigate immediately to some other route before rendering the route that you are trying to visit.
(1:49:34) So let's maybe have an example in this about route. Right? Let's go to this about route uh in here and let's say maybe based on some condition we need to navigate to another route. if we try to visit the about route. So maybe we have a condition here. Uh I'm just going to add if true, which of course doesn't make sense. But let's say we have a condition here.
(1:49:59) And if this condition is true, we need to navigate to a different route. In this case, it is recommended to use this navigate component that we can import from react 10stack react router. Instead of using the use navigate hook and in here, you can uh sorry, of course, we need to return this.
(1:50:19) And then you can navigate to some other routes and you have all the options that you can post to a link. So let's maybe navigate to posts. So now as you can see if we try to visit about I'm clicking on about here but it is going to post. If we try to visit it uh using the URL we're going to get posts. So this is also another possible way to navigate in your tenstack router applications.
(1:50:47) One final thing I would like to mention regarding uh navigation before we move to something else uh is also we have uh a couple of um a hook and a component here that can be useful sometimes which is use match route and match route component. So you can use these to check if a route is currently matched and you can also check that if the currently matched route is pending or not is currently being loaded or not.
(1:51:12) And this can be useful if you would like to maybe display some sort of a spinner when you navigate between uh different routes. So we have a component here. Um we have an example here where we have a component and we have a link to a route called users and then we are using this match route component to check if the users route is matched and it is pending.
(1:51:29) So if it is matched and it is pending we need to display maybe a spinner after this user's link. So this is something that you can do with this component. You can also posit a function here and you can also use it uh in this way. Use a hook. Use match route. From this hook you're going to get a function.
(1:51:47) You can posit the route that you need to check that it is matched. And you can also pause pending. And you can do something if this route is matched and currently pending in an effect. For example, outside of your markup. If you need to use it in your markup, then the component option will be more suitable in this case. But I guess that's maybe all what we need to do regarding navigation for now.
(1:52:10) Let's now move to something else which is context. In 10 stack router we have this idea of context. It is somehow similar to the react context that you are maybe familiar with but they are two different things and they can actually be used together. So in tstack router in any node in our route tree we can define some context.
(1:52:35) So let's say in our root route when we initialize our router we pass some context uh this can be just some data a state it can be a function anything and when we define it here in the root it is going to be available for all of our routes we can access it in any route component or in any load function and of course we are still going to take a look at load functions um in an upcoming section.
(1:52:53) So this can be useful for sharing data across multiple routes. We can also pass functions like maybe data fetching functions or we can maybe initialize clients uh in the root and then pass this client everywhere so that it can be used without having to import and export stuff.
(1:53:11) We can also maybe use it for authentication information where in the root we maybe have some uh authentication provider which provides us with information about the user if the user is logged in and so on and we need to have access to that everywhere so that maybe we can protect some routes then we can use this context.
(1:53:30) We can also use it for other things like maybe breadcrumbs uh SEO stuff, title tags, meta tags, uh descriptions and so on. We can also instead of defining the context in the root and have access to it everywhere, we can also somehow we are going to see of course define some context in a specific route. So let's say here for example when we do so this context is only going to be available to this route and any of its children.
(1:53:53) So we can also do that if we have some data uh that is maybe only used for a certain segment in our route tree. So that's the general idea. Let's have uh maybe a couple of simple examples and maybe if you would like maybe we can do uh another video to have some more uh realistic examples for using context.
(1:54:13) But let's now go in here and we need to have a couple of files opened. Let's open our main uh thetsx file and also let's open our root route which is undersc root in our routes folder and let's say we have maybe um some authentication system. Of course what we're going to do is not very realistic but let's just have a simple example where we have a user uh that we need to post to all of our routes and if that user exists it means we're logged in. If not it means we're not logged in.
(1:54:44) So in my root route I'm going to just uh define a simple type for our user. Let's say we are going to have an ID and a name. And then if we need to pass some context in our root route instead of calling create root route we call create root route with context which we can import of course from uh from tstack react router. And now we can remove this one.
(1:55:08) And in order to have type safety when we use this context. So when we set the context or access the context we need to specify its type and we can do that by passing here a generic and we can pass the type of our context. So let's say in our case let's define an interface here. Let's maybe call it root route context. And let's say in our case we're just going to have a user that we need to pass as a context.
(1:55:35) And this can be of type user or it can be null as well if we are logged out. Now we can just pass this here in this generic. And also notice that create root route with context is used a little bit differently. So this is not a function that we call directly. However, it is a function that returns another function that we need to call.
(1:55:56) So we need to call this function first here and then whatever function returned by this we're going to call it in order to pass our component and so so need to add just a couple of brackets here. And now we're going to need to pass an initial context. So if we go here we're going to main.
(1:56:15) tsx we're going to find out that we are now having an error because we specified our router to have some root context. However, we're not passing any context when we create our router. So to do that we need to pass here context and pass some initial context. In our case we have user and it can be null or a user. Of course initially we can just set it to null and then we can populate it later as you are going to see now.
(1:56:38) But first before we can see how can we uh maybe manipulate this context uh update it update the user or remove the user maybe when he logs out and so on. Let's first see how can we use it in our components. So as we've mentioned now that we have this context in our root we can use it anywhere including in our root component or in any other child route.
(1:57:00) So let's try to use it in our root component in here. And this is by using a hook. So in here we can access a hook inside of our route. So in any route sorry in any route remember the route is this constant that we define here. And in router we're going to have access to use context or use uh route context. And in here we're going to have access to our user.
(1:57:28) So what I'm going to do is maybe after this uh root route text that we have here I'm going to put this markup where we check if we have a user we're are just displaying a text of welcome and then user name. Otherwise we just have a text of welcome guest. So let's save this and we should get welcome guest. If we uh in here when we initialize our router maybe add some user let's add some ID and some name uh like so we should get here welcome text.
(1:58:08) So this context is going to be available in our components as we've seen here and also in load functions which are functions uh that we are going to use in order to load data in our routes. And this is a topic that we're going to discuss next. But first, as we can see, uh, when we pass data to our context, we're just passing some static data here.
(1:58:28) However, what we need to do is instead of doing so, we need to make this a react state so that we can manipulate it from our application. Maybe if the user logs in, we need to populate it. If the user logs out, we need to remove it and so on. So, we don't just need to pass some static data. We need this to be some sort of React state. So let's see how can we do that now.
(1:58:50) So in order to pass some state to our tanstack query context and be able to manipulate it in our application we need to use the use state hook. Also in addition to state maybe you are using some hook some other hook maybe u an authentication provider use o for example and you need to pass data from use o to your context. In this case, you're also going to need to use a hook.
(1:59:08) And as you might know, we cannot use hooks except inside of React components. Over here, when we initialize this router and pass our context, we are not in a React component. So, what we need to do, let's get this back to null. And what we can do is we can initialize this context in a different way.
(1:59:28) So, in our router provider component, we can pass context as well. So what we're going to do is we're going to create um a component. Let's call it maybe app or so. So let's create a function app. And in here we're going to do stuff that we need to do in order to initialize our context or to get our context and then pass it to router provider.
(1:59:52) So I'm going to copy this cut it from here and return it here and use app here instead. Right. So now we have the chance to use hooks in this app component, use context, use any uh provider and so on and pass data from this provider or from this hook into our context by passing the context prop here, right? So let's do that. But first of all, uh remember we had here uh not here actually in this root component, we had this type for our user.
(2:00:25) We're actually going to need to use this in multiple places. So I'm going to cut it from here and put it somewhere common. Let's say maybe in our source for uh source folder. Let's create a folder called types and then index.ts or so. And then let's put this here and export it uh so that we can use it here. Let's import it here. And we're also going to need to use it here as well.
(2:00:52) So let's say we have uh some state. So I'm going to create a state user set user and we're going to use our uh use the use state hook and this state is going to have a type of user which we can import or null right and let's say let's initialize it to null.
(2:01:18) So initially we're not going to be logged in and now we can simply pass this state as our context. So in here we can pass our user uh sorry in an object we can pass our user like so. By doing so we have this set user function that we can also pass in our context and it can be available everywhere in order to be able to set the user to something else. So maybe when we log in or log out and so on.
(2:01:42) And of course this is a simple example in reality. Maybe you are using some authentication library and you're going to be maybe getting some information from a use o hook uh maybe the user stuff like that and then you can pass it to your context as well but we're just having a simple example here. So now since we are having null here we're we're getting welcome guest but of course we can change this to something and uh sorry let's give a name and we're going to get this here right but let's actually leave it as null and now let's have some sort of a way to maybe login
(2:02:20) out and so on and set this user so what I'm going to do is remember when we defined the type for our context which is Here, let's say in addition to the user, we're going to have a login function where we're going to get our user of type user and it's going to be a void function.
(2:02:42) And we're going to pass this function in our context here in the root so that it can be available everywhere, right? And let's also have a logout function which is going to be uh just a void function. And in this function, we're going to uh set our user to null. So now that we have that in our context, we need to specify that here, right? So what I'm going to do is I'm going to define these functions here.
(2:03:10) So let's create a function call it login and we're going to give it a user that we need to login of type user and then in here we are just going to uh set user and set it to whatever we pass to our function. Right? And similarly, let's actually duplicate this. Create logout. Set user to null. And we don't need this.
(2:03:34) And now we can just simply pass these functions here. So login and log out. Oh, sorry. Log out. And we're still getting an error. Yeah, we need also to to uh pass these functions here since they are part of our context. So in here maybe let's uh just pass an empty function for login and logout because anyways we are populating these functions here uh in this app component.
(2:04:02) So now these functions are going to be available everywhere in our app. So let's try to use them uh maybe also uh also in our root uh root component. So in here if we are logged in let's add a log out button and uh if we are logged out let's add a login button. So if we're logged in, I'm going to add a button here. Let's say log out.
(2:04:24) And uh when we click on it, we need to call the logout function that we pass to our context. So it should be available here. So let's also get login and get logout. And in here, let's call log out. And let's also copy this. And if we are logged in uh or sorry or if we are logged out let's say login and let's call login and just pass it some dummy user.
(2:04:51) So call login and in here let's maybe add an ID and some name of test. So now we have this login button. If we click on it however um as you can see nothing is going to happen. If we try to maybe go to a different route, as you can see now it is updated. So we get our log out and we get test here. But we had to move to a different route in order for this to update.
(2:05:24) So what we need to do let's maybe refresh this so so that we are logged out initially. What we need to do is when we update our context by updating our state which we are passing to our context, we need to call a function called router uh.invalidate invalidate in order to recomputee our context and updated in our UI. So in here in main.tsx we already have access to the router that we define here.
(2:05:47) If we are not here we can access this router using the use router hook. But uh we don't need to do that since we have already uh we already have access to router. So we can simply call router.invalidate invalidate here and we can do it here as well when we log out. However, if we save this, let's maybe refresh as well. It is still not going to work.
(2:06:13) And this is actually an issue that we can take a look here. Uh we can take a look at it here. And it is currently still opened. Uh but we have a couple of workarounds in order to fix this problem. So what is happening is we're setting our user here. But as you know when we set a state in React it is not set immediately.
(2:06:34) So when we run some code after setting a state it is not guaranteed that our state is updated yet. So this is probably what is happening when we set this user our state is not yet set and therefore router invalidate is is not going to do anything. So one way to fix this problem is to maybe wait for a second. So let's maybe make this function async and let's wait for a second here before calling router.in to invalidate.
(2:06:59) So by this time uh the user should be set at this point. This is of course uh not a great way to fix it. But if we give it a try, click on login. Wait for a second. As you can see, now we get our updated UI. But this is maybe a very hacky way to do it. One other way is to call a function called flush sync.
(2:07:20) Sorry, flush sync that we can import from React DOM. in this function uh this function we can pass it another function and if we set any state in this function it is going to be set immediately. So if we do any other thing after calling floss sync we're going to be guaranteed that the state is updated. Now if we save this and try again login as you can see we immediately get our updated uh our updated UI and we can do the same for log out as well wrap it in flush sync uh and this way if we log in log out both are working immediately. We can also in our dev tools uh take a look at our context as well if you need
(2:08:02) to maybe debug something. So if you choose any route you can see uh which context is available in this route. So in here we have our context we have our user and you can maybe use this for debugging if you have some sort of a problem. Um as we've mentioned we can also u make a context available to only a certain branch in our tree. However this is something that we're going to discuss when we discuss uh load functions.
(2:08:30) But that's it for context for now. Of course, this was just a very simple example, but if you would like, maybe in another video, we can actually uh use an actual authentication service integrated with our context and use it in our routes and so on.
(2:08:47) However, for this video, I just need to discuss as much uh features as possible uh using these simple examples. When it comes to loading data in 10 stack router, we don't just load data inside of our route component, maybe in an effect or so. However, how we do it is by defining a load function that we can pass here to create file route.
(2:09:07) So in here we can pass a load function or sorry loader function and in here we can do any data fetching that we need. This ensures that the data required for the route is going to be loaded as early as possible and it can also be preloaded even before we visit the route. We're going to talk more about uh pre-loading later.
(2:09:27) And also by default any data that we're going to load here is going to be cached as well. And we can control the behavior of this cache. We are going to also uh discuss caching in a later section. In this loader function, we're going to receive things like the context. We're also going to get our uh URL parameters in params.
(2:09:45) We're also going to get the route itself, information about the route. However, we're not going to get the search parameters. So if you type search here, we're not going to find any property for search parameters. And this is for a reason that we're going to discuss also uh in a moment. And we also have in addition to loader, we also have a before load function that we can pass here.
(2:10:09) And this can be very useful in many situations. So for example, maybe we need before rendering our route, before loading any data, we need to redirect to a different route. Maybe we're not authenticated for example. So need to redirect. And also remember when we discussed context, we mentioned that in addition to having root context that is going to be available everywhere, we can also have context for a specific route and it's going to be available only for this route and its children.
(2:10:38) And this can be done using this before load function by returning an object here. If we return an object, this is going to be the context only for this route and its children. And we're going to try that uh in a moment also. But let's for now load some data from this dummy JSON API.
(2:11:00) So we have this dummy JSON placeholder API here where we can just send some requests and receive some dummy data. So let's use that to maybe try to load some data in our application. So what I'm going to do is I'm going to define some functions to fetch some data from this dummy API. Uh I'm going to put these in maybe in our source folder. I'm going to create a file inside of data.
(2:11:20) Let's call it posts also since we're going to load some dummy posts in here. I'm going to paste some stuff and let's go through it quickly. So I have the types that are returned by this API. So the post is going to contain ID, title, body, user ID and so on.
(2:11:40) It also returns other stuff as well, but uh let's keep it simple and let's say we are only caring about uh these properties. We're also going to load comments for the post and this is the type for it. And when we send a request to fetch posts, we're going to receive the posts uh which are an array of posts in addition to pageionation information. So we have total skip limit and similar for when fetching comments as well.
(2:12:01) And in here I have a couple of or actually three functions. One to get a post uh or sorry to get a list of posts. And we have page here where we can load different pages. So we call this dummy API and just add a limit and skip to load different pages based on this page argument here.
(2:12:22) And then we return our JSON if our response is okay otherwise we throw an error and uh we do the same for the other functions as well. So get post this gets a specific post by receiving the id and we call this endpoint pass it the ID return the data or throw an error and so on and similar for comments as well. So I'm going to save this file and now let's try to use uh these functions in our route.
(2:12:42) So remember we had this route posts.index.tsx which is uh / posts which uh should maybe contain a list of posts. So let's try to call the get post function in order to load some data and then use this data in our component. Let's also try to pass uh the function the get posts uh function this one as a context for this route by returning in here.
(2:13:08) So in before load we can just return and uh let's say get posts and let's import our get posts function. This is going to ensure that this context is available for this route which is / posts and if it has any children. So in our loader function we can get our context and in our context we're going to find that we have access to our parent context user login logout in addition to get posts and this is going to be similar for uh if the post rout had any children as well they're going to have access to get posts. So
(2:13:48) context can also be useful for passing functions that are maybe going to be used by multiple routes. So maybe in our example it's not very useful but as you can imagine there can be use cases to this but let's now try to in our loader function now get from our context uh let's dstructure our get posts function and let's call it by creating a constant call it posts and then uh await get posts and since we're using a wait let's make this an async function but remember uh this function is going to return uh posts response which is going to contain the posts and the pagionation
(2:14:27) information. But let's say we only need to return the posts. So let's in here return posts or actually sorry let's return an object containing our posts which are going to live in posts.posts. Um I think I maybe have yeah I have a comma missing here. So by returning some data from this loader function this data is going to be available in our component.
(2:14:53) And how can we access it is by also using a hook. So let's in here use a hook inside of our route. And this one is called use loader data. And since we have type safety for everything, of course, we're going to get autocomplete here for our posts. It's going to be correctly typed as well.
(2:15:13) And we can just uh simply loop through our posts and display them. I'm going to put some code here. This is pretty straightforward. Let's say uh maybe in here. Let's put this loop. So what we're doing here is just a a loop through our posts and then displaying a link that is going to display the title of the post and it's going to take us to posts/post ID and we're passing the post ID of the uh post that we're get that we're getting in our loop. However, it looks like we have an error.
(2:15:42) Uh let's maybe refresh. Yeah. So when I refreshed, here we go. We have our list of posts here. When we click on one of our posts, we're going to go to posts uh / id. And in this route, we can load this specific post. Uh but let's leave it like that for now, and we're going to do it later. But let's now say we need to implement pagionation for our list of posts.
(2:16:08) So let's say in our URL, we need to be able to pass uh a URL parameter. Let's say page. And if we set it to two, for example, we need to load page two. Of course, currently um this is not going to do anything since in our load function we are not passing a page here. So remember in this function get posts.
(2:16:29) We can pass a page and this is going to add a skip uh in our URL call and it's going to load a different page. So I'm limiting by 10 posts here and then I'm skipping by the page number multiplied by 10. So if we call this function and pass it whatever we have in our URL parameter, we should load the next page. But there is something important that you need to know when you try to access search parameters in your load functions.
(2:16:49) Let's first um add this search parameter. We've seen how to do that before. So let's do it quickly. So we just need to import um z from zod. And then we define our schema. We're going to just have a page of type number. And let's also make it optional.
(2:17:07) And if it does not exist, we're just going to fall back to one. And now in here in our route we just need to pass our validate search and pass it zod validator since we are using zod and then pass this our schema like so. But as we've mentioned in this loader function we don't have access to our search parameters and we need to access our search parameters here in order to get the page and boset to get post function.
(2:17:33) So why don't we have access to search parameters here? There is actually a reason for that. So tst query is going to as we've mentioned cache the data that we return here from our loader function. And since in our case the data that we return in our loader function is going to depend on something in our search parameters which is the page.
(2:17:53) In this case we need our cache key to be unique based on the route name which is /osts but also based on the page that we're trying to load. So when we cache the posts route, we need our cache to take into account which page exactly we are caching so that when we try to load a certain page, we're going to get the correct cache for the correct page.
(2:18:14) If we don't take this uh page search parameter into account when caching our data, we might get a wrong page or wrong data when we load our data from the cache. And don't worry, we're going to talk more about caching later. So if we have access to search parameters directly here in our loader function, this can lead to bugs because we need to somehow explicitly let tack router know which data exactly in our search parameter we depend on to load our data so that it can catch our data correctly.
(2:18:44) So we can do that by specifying loader dependencies here or loader depths and in here we're going to get a function and in this function we're going to have access to our search parameters. So let's just uh return something here and uh here we have access to search parameters and we can return an object with the stuff that we depend on in our search parameters.
(2:19:07) So in our case it is just the page. So we can return the page in an object and access the page from our search parameters page like so. By doing this, since we are accessing search page here, this is going to be a dependency to our load function and it's going to be taken into account when caching our data.
(2:19:31) And now since we are specifying our dependencies here in our loader function, we have access to these dependencies. So in here, we have access to dependencies like so. And in dependencies, we're going to have access to our page which we are returning here. And by doing this this way, tan stack router will be aware exactly on what you depend on from your search parameters and caching should work correctly in this in this way.
(2:19:56) So let's now try to load different pages. Uh let's why don't we um before our title maybe put our ID here. So post do ID so that we just uh know uh we just can make sure that you're loading different posts for different pages. So now if we go to /posts, uh looks like we're getting page two. Maybe you have a bug here. Oh yeah, sorry. This should be page uh -1 * 10.
(2:20:22) So that when we load page one, our skip is going to be zero. Sorry for that. So now if we refresh here, we should get the first page. Now if we pause here page two we should get the second page page three and so on. And now you can just simply uh add pagionation buttons here to uh go to the same route and just update this page parameter and we've seen how to do that in a previous section.
(2:20:54) So let's have a quick example here to add a button maybe to go to the next page. Uh so in here in our component maybe after the posts loop let's maybe remove these old links. I'm going to put this link here where we navigate to our current route which is the post route. However, we just update our search parameters.
(2:21:14) Uh I'm passing a function here where we're going to have our previous search parameters. So we increment the previous page and fall back to one if uh we did not have a previous page. And of course you can do the same for a previous page button. And uh you know you can add conditions to show or hide these buttons.
(2:21:32) So if you are in page one for example uh you should not have a previous page button. If you are in the last page you should not have a go to next page button and so on. So you can add these conditions as well. But let's try this. So go to next page and uh as you can see looks like it is working fine. So in this route we only uh needed to send one request to fetch our posts.
(2:21:57) However, in many situations, you might have to send multiple requests here and you also need to ensure that you do it as efficiently as possible. So, let's say in one of our posts, so uh let's go to posts maybe / one or so. And in here, let's say we need to load the data for this post. Of course, as we know, we have the necessary functions to do so.
(2:22:23) we have get posts or get post where we pass it the id and we get the post and also get post comments where we get the comments for a specific post. So now let's say we need to send these two requests in the load function for this route. So this route lives here in posts post id tsx. So let's open that up and in here let's pass our loader function and let's load our data. This is going to be async of course.
(2:22:49) So let's say uh let's create a constant post and then let's await get post and pass it the id. The id is going to live in our URL parameters which we have access to here. So params and in here we can just pass params id uh or sorry post id which is going to be a string. Uh in this function we expect a number. So we can just parse it to a number like so.
(2:23:14) And we can do the same for a comments and just call get post comments like so. And what we can do is we can just return the posts or the post and the comments for the post. If we take a look at our um network here, we're going to find out, let's maybe refresh. We're going to find that our requests are being sent. However, this one is going to be sent first and then after it is done, this one is going to be sent after it.
(2:23:49) And this is of course not very efficient since these two requests uh do not depend on each other. So we don't have to wait for this to finish in order to uh run this other request. We can run these in parallel by using promise.all. So let's maybe copy this uh get comment get post comments. Let's remove this. And now let's add an array here where we're going to get our post and comments. And let's in here instead await promise doall.
(2:24:12) And of course, as you may know, in promise.all, we can post an array of promises that are going to run in parallel. So we need to put here our comments one. And let's copy this and put our post one. So it's going to look like so. And now we're going to have the same thing.
(2:24:33) However, if we refresh, as you can see, both requests are being sent in parallel. And now we have our data. We can just uh add some markup. Remember in this component we had the post in a different component. And we get the hooks for it using get route API. So in here we can get our use loader data and from this hook I'm going to get my comments and my post.
(2:24:58) So in here, use loader data. And then let's get the post and the comments. I'm just going to paste some markup here. Pretty pretty straightforward. Let's save. And in here, I'm just listing my post title, the post body, the contents of the post. And in this div, we have the comments. Each comment, I have it in this alli with this purple background. And I have the body of the comment and the username of the uh comment author.
(2:25:28) We have a TypeScript error here because when I defined uh the type for the comments, I forgot to add the type for the user which is returned by the API. So we have the user ID and username. So now as you can see we have our post here with our comments. But let's say uh let's simulate our request uh being maybe a little bit slow and let's say the comments request is slow.
(2:26:01) So in here when we get our comments let's add some artificial delay here like so. So I'm just adding a delay of 3 seconds before we return our data. Now, if we save this, refresh, as you can see, we're going to get this blank page for 3 seconds or so, and then we're going to get our route displayed here. And the same is going to happen if we, let's say, in our posts route, and we navigate to uh any post.
(2:26:25) We're going to be stuck here for 3 seconds and then we're going to navigate. So, we can make this experience a little bit better by in our route. So in our post / id route we can here define a pending component and this component is going to be displayed instead of our um route component. This one that contains the post until our route is loaded.
(2:26:52) So as long as our component is pending or our route is pending. So in here uh let's just pass a function and you can put maybe a skeleton or something like that. However, for simplicity, I'm just going to put a div with some loading text like so. And uh I have a comma missing here. So now if we refresh, as you can see, we get this loading.
(2:27:17) And also if we maybe go to posts and then go to any post, we're going to be uh having a little bit of a better experience by having some loading indicator uh instead of just being stuck in the previous route. And we can also control how this uh pending component works by specifying some options either in the route or in uh our router when we first define our router here. But let's do it for this route first. So in here, let's say uh I'm going to go back again.
(2:27:49) Let's refresh. By default, this component is not going to show up except if our loading took more than uh a certain amount of time. I think 1 second or so. So I'm going to click it. it is not going to show up except after 1 second. After 1 second, we're going to see this. We can customize this by going in here and defining um pending ms milliseconds.
(2:28:15) And if we set it to zero, for example, sorry, zero, it is going to show up immediately. So if you go back so refresh click and immediately we're going to get this loading uh component here. And if you would like to set this option globally for all of our routes in here when we define our router we can uh define a default pending ms here but uh I'm not going to do it here. Let's just keep it in our route. We also have another option.
(2:28:49) So let's say um let's maybe go back to our function and remove this delay. And let's say our function our um data is loaded quick enough. If you go back now uh maybe refresh click on a post we're going to see this loading component for a very short amount of time and it can be even less than uh the time that we've seen here.
(2:29:17) So if it maybe showed up for only 1 millisecond or so, it's going to just flash and disappear immediately, which is maybe not a very good experience. And for this reason, by default, uh 10stack router is going to show this pending component for at least 500 milliseconds. Even if the data did not take 500 milliseconds to load, this component is going to show up for at least 500 milliseconds to avoid this uh flashing behavior.
(2:29:41) And we can also customize that by adding pending minimum milliseconds here. If we set this to zero for example and uh let's maybe try or actually to try it maybe set it to a large number so that we can see that it's going to stay for this number as a minimum. So if we go now as you can see our data is probably loaded but we uh still have this loading component for this amount of time.
(2:30:06) By default, it is 500 millisecond uh milliseconds to avoid this flashing behavior if your data loaded in a very short amount of time. And this option can also be set globally here by specifying default pending uh minimum milliseconds as well. What we can also do to make our route uh load faster is that we can instead of waiting for all of our data to be loaded before rendering our route, we can just wait for important data to be loaded then render our route and wait for maybe non-critical data to load in the background and then display it later after rendering our route.
(2:30:45) So let's have an example by maybe uh in our posts functions here. Let's get this back uh this time out here so that our comments are going to maybe take some more time to load than our main post uh that we're loading with get post here. So if we refresh now, we're going to we're going to get some loading time here.
(2:31:05) But what we need to do is we need when we uh visit this route to render the route immediately after our post is loaded even if the comments are not loaded yet. And then when the comments are loaded we need to display them later. So in this case we don't have to wait for the comments in order to render our route and we can do that by simply uh sorry in here in the post id route we can simply let's remove promise old now and we're going to do it in a different way.
(2:31:36) So let's get this back to where we load our posts like so. So await and then let's copy this and let's remove this. And what we can do is we can load our comments. So let's define comments and instead of awaiting our comments, we can just pass this as a promise. So let's maybe call it comments promise instead so that this is clear and pass it here as comments promise.
(2:32:06) So in this case, we're going to start loading our comments. However, we're not going to wait for it before rendering our route. We're only going to wait for posts uh for sorry the post since we are awaiting here. And once this is done we're going to render our post while this is loading in the background.
(2:32:25) And when this is done we're going to display it somehow. Uh we're going to see now of course. So now if we save this and go back to our post component now we're going to have an error because this is a promise and not our data. So we need to get the comments promise from here.
(2:32:45) And of course now we cannot loop through this because uh this is a promise and not our data. We need to await this promise somehow in our markup before uh displaying this ul which displays our comments. We can do that by using a component provided by tens router. But let's first uh mention something. So in here notice uh sorry not in here in our route. Notice that I in here I put this comments request first and then I put the uh request that we're awaiting here. If we do it the other way around.
(2:33:18) If we await this first and then uh fetch our comments, it is going to also work. We're going to wait for the post to be loaded and then render our route and this is going to be loaded in the background. However, we're not going to start to load the comments in the background until the post is loaded. And this is unnecessary by putting this after the comments.
(2:33:35) We're going to start loading the comments in the background and then uh start fetching the data for the post. And when this is done, we're going to render the post. So, we're just saving some time by starting this a little bit earlier. All right. But now, let's go back to our post component.
(2:33:55) And we have a component provided by tanstack router called await. So in here let's put a component called await that we can import from tanstack react router. And in here we can pass a promise that we need to await. So in our case the comments promise can also pass a fallback that is going to display until our promise resolves.
(2:34:19) So you can put also a skeleton uh things like that. I'm just going to put maybe a div. Sorry. Let's put a div here with some loading text. And now when our promise is resolved, we're going to get our resolved data here in a function that we can pass in our children. So in here we can pass function that is going to contain our comments like so. And by having our comments, we can just return our ul.
(2:34:45) So in here we're going to have our comments. Now we can just copy this URL from here. Cut it from here and put it inside of here like so. So now let's maybe try to refresh. As you can see, we get our post immediately and then the comments are being loaded in the background. So this is of course maybe a much better user experience. Let's talk a bit about how we can handle errors in our tens router application.
(2:35:17) So let's say for example we're trying to access a post that does not exist. So I'm going to go to uh /ost slash some ID that does not exist. Maybe you can put uh some numbers or some letters here. And as you can see uh we're going to get an error fail to fetch post which is the error that we are throwing here uh in our data posts file in our get post function.
(2:35:43) In here we are throwing this error and this is what we are getting here because in this case the API is going to return an error. What we can do is we can of course customize this error page and make it look like uh it belongs to our application a little bit more. And we also have a call back that is going to run in case any error happened in our route.
(2:36:02) And in this callback we can maybe uh report the error to some error reporting service for example. So let's go to this route. Of course, what we're going to do can be done in any route, but let's try in our posts/ id route. In here, we can have this code back on error that is going to run whenever an error happens. And we're going to receive the error here.
(2:36:25) And in here, we can maybe do something like reporting the error as we've mentioned. For now, let's just maybe console log it. And uh let's make sure this is working. Oh, sorry. Let's make sure this is working by taking a look at our console here and we should get the message that we are logging here error loading post and then we get our error and to customize the error component similar to pending component we also have error component as well.
(2:36:54) So in here we can pass error component but in here we're going to have access to a couple of things. So in this error component we have access of course to the error itself and we also have access to a reset function. In the error we're going to have the error itself of course the error message and so on. And this reset function we can call it in order to retry and rerender our route.
(2:37:18) So let's say in here we can return a component. Let's return a div. And maybe let's display the error message like so. And maybe after the error message, let's maybe save this and refresh. We should now get this message. And we can have a button here and call this reset function in order in order to uh retry and uh rerender the route. So let's add a button here. Let's say maybe retry.
(2:37:48) And then on click we can uh just call our reset function like so. So now we should have this button and this button is going to try and rerender the um route component this component here. However, it is not going to retry to load the data. So this loader function is not going to run again. And actually the error in our case is coming from this loader function.
(2:38:17) It's coming from uh when we fetch the post. So maybe in some situations we would like when we retry uh to reload the route to try to refetch the data as well. So if we open our network here and click on on retry as you can see no requests are being recent.
(2:38:39) So in order to retry and uh fetch the data in addition to rerendering the route we can use router.invalidate instead. Remember we've used router.invalidate before to uh recomputee our um context. We can use it also for this purpose. So let's define a router here. And to access our router, we can use the use router hook. And of course use router is imported from uh 10 stack router.
(2:39:04) And now instead of reset, we can maybe call router invalidate. And now if you save this, let's also refresh. Let's clear our network here. And let's click on retry. And uh as you can see now when we retry the requests are going to be uh resent. Of course we are still going to get the error since we are passing a wrong ID here.
(2:39:30) But now let's say we don't have this uh network or API error. So let's go to a post that actually exists. Now we don't have an error. Everything is working fine. Let's say we had another error that did not happen in our loader function when we load our data. However, it happened when we render the component itself.
(2:39:48) So in here in our post component, let's say we maybe try to access something that does not exist. Of course, it this is going to be called by TypeScript. But let's say you accidentally have this error and now our um our error component is going to show up with our error.
(2:40:06) However, if you notice in the uh in the console, we do not get the on error uh call back here. This did not run when we had an error in our component when rendering our component. This will run if you had errors while uh loading your data. However, if you had errors in your component while rendering your component, we're going to get these in on catch.
(2:40:32) So, we can have on catch here and in on catch, we can uh also report this error. So, we're going to get the error. Let's console log uh the error as well. Let's maybe say here on catch and if we save this and uh sorry and refresh now we should have this on catch running and in here we can maybe report the error also. So what happens behind the scenes is when you render um your component your route component tstack router is going to automatically wrap it with a component which is catch boundary and this component is going to catch any errors that happens in its children. And if an error
(2:41:14) happens in the children this component is going to catch it and when this happens you have this uh on catch call back here that you can pause in order to see the error log it and so on. But we don't have to do that manually. This is done uh by stack router. And we can access this on catch function here.
(2:41:32) When we define uh our route in our app, we might have other errors like for example 404 errors. If a route is not found. So in here, let's try to visit a route that does not exist in our folder. I'm going to type anything here and I'm going to get this not found component here. So this is a default component that tack router is going to display if you type a route that is not matched in your folder.
(2:42:01) However, of course, we can customize it as well. And to do that, we can create a not found component for all of our app by defining this in our root route. So let's go to our root route. And in here, um, when we define our route here, we can specify a not found component like so. So let's say for this one let's maybe return a div and let's explicitly here type root uh not found in order to know which component exactly is being rendered by saving this and let's refresh and we're going to get root not found and by root note found I mean this is the notefound
(2:42:38) component coming from the root route we can however be a little bit more specific so remember we had in our app a settings route and in settings we had uh general We had payment, we had profile. What if we type here something uh settings/ something that does not exist. Remember in our settings route, settings is a parent.
(2:43:06) So if we take a look at here, settings is a parent to payment and profile. And in this parent, if we go in our folder to settings, uh settings layouts settings.tsx, tsx this parent has an outlet and it displays the children and so on. So if an error happened a 404 error happened where the parent is settings and the child is not found then this settings layout is going to be used and the default 404 uh error component is going to be used instead of this outlet.
(2:43:38) So as you can see we get our layout normally however our settings layout normally. However we get the default not found component here. However we can customize this by specifying in the settings parent itself the uh not found component. So let's say in here add some text of settings not found like so. Now if we refresh this we're getting uh we're going to get settings not found.
(2:44:06) So what is going to happen is the router will try to use the closest matching route that has an outlet and it's going to display the not found component using this route. However, we can customize this behavior as well. If we would like to um make the root notefound component be used for all of our routes.
(2:44:31) When we define our route which is uh in our main.tsx tsx file. In here we can specify um an option which is not found mode. If we set this to root then the root not found component is going to be used as you can see. However the default option is fuzzy which is going to be a little bit smarter and try to use the closest route with children in order to display the not found component like so.
(2:44:55) So I'm going to leave it like that fuzzy which is also the default. So you can maybe remove this option but remember if we don't have uh a not found component either for our root or for maybe uh the settings parent here.
(2:45:15) So let's maybe comment this for a moment and refresh this default not found component is going to be used. So maybe you would like to have a default a different default not found component instead of having to specify the not found component for each route or for each parent uh each parent component where you need to display a 404 error. In this case you can in uh main.tsx here when we define our router specify a default uh not found component like so.
(2:45:40) So for this one, I'm going to just put uh default not found as as a text here. And now, as you can see, we get this instead. But of course, we can still override this by going to our settings layout and uncommenting this.
(2:45:59) Now, this is going to be uh it's going to have more priority, and we're going to get it here. All right. So, I hope that's clear. Sometimes however uh we might have a matching route but the resource that we're trying to fetch does not exist. So for example we have a route which is post/ ID. So this route exists. However we might not have uh the ID that we passed here in our back end.
(2:46:23) So let's maybe pass a large number here that probably does not exist. So this route exists. However, when we fetch our data from the API, we're going to get a 404 from the API. What is going to happen is uh or sorry, this is posts. What is going to happen is remember we are uh handling errors using uh let's go back to the post route post/ id.
(2:46:49) We're handling our errors using this error component. And when you fetch our data which is in posts.ts, ts uh any error we're going to get we are just throwing an error. So actually not here in here in get post we're throwing an error for any error that we're going to get.
(2:47:09) So by throwing an error here this error component is going to be displayed. However we need to be more specific and display specifically a 404 error if we get a 404 error from the API. So if we inspect here, open our network, refresh, when this request uh is sent, we're going to get in the response. So let's take a look here. In the response, we're going to get a 404 not found error.
(2:47:38) So maybe we can check uh in here when we send this request if we had if the response is not okay maybe before throwing an error we can check if the response status is 404. In this case we might uh we can make tanstack router display the 404 component instead of the error component by throwing not found.
(2:48:03) So we can import not found from tstack react router and throw this instead of throwing an error. Uh sorry I have a typo here. Not sure why it is not autoimp importing but uh let's just put it here like so by throwing not found when we get a 404 error. If we refresh now uh we should get the default not found component. Remember uh since we specified this in our main.ts the tsx to be our default component.
(2:48:34) However, of course, we can still customize it specifically for this route by passing uh sorry in here in posts uh post ID. In addition to our component, we can have a not found component as well. And in here for this one, let's say post not found. And if we save this, refresh, we're going to get post not found. So, this is mainly it.
(2:48:59) You can also find a page here in the docs for not found errors if you'd like to read more about this. However, uh we have covered mainly everything in here. Let's discuss one final thing regarding error handling. So let's say we are visiting a post and remember in our posts routes we were loading the post or we were waiting for the post to be loaded before rendering our route and then we loaded the comments in the background.
(2:49:26) Let's assume some error happened when we are loading the comments. So let's go to this comments function in here and let's maybe uh get this back time out and then let's say after this timeout some error happened. So let's throw a new error and let's say failed to fetch comments also. Now if we try to refresh this our comments are going to be loading and then our whole page is going to crash.
(2:49:55) It would be much nicer if we keep our post as it is and just display an error here in place of the comments. To do that we can remember in our uh post route we are rendering this post component. In this post component we are having a waited here in order to wait for the comments to load and then display the comments. What we need to do is we need if any error happened in this awaited component we need to display an error component instead of just crashing the whole page.
(2:50:24) So what we can do is we can wrap this in a catch boundary component that we can import from 10 stack and we can wrap everything like so. And by doing this if any error is thrown by the children of catch boundary we can instead of crashing the whole page catch this error and display an error component instead.
(2:50:48) So in here let's say uh let's have some text failed to load comments and also if we would like to log this error we can have an on catch call back here. However, this is optional but what is required is um a prop called get reset key and in here we can return a function and in this function we can return a certain key anything and when this key changes this error boundary or this catch boundary is going to be reset.
(2:51:20) So we can put here something dynamic that we need uh whenever it changes the catch boundary will be reset. However, for now, let's just post some static string. And maybe you can implement a way to update this key in order to reset the error boundary. However, I'm going to keep it like that for now.
(2:51:40) And if we now save and refresh and wait for the error, we should now get fail to load comments only here. However, we still have our post and we do not crash our entire page. Let's talk about code splitting and pre-loading in Danstack router. And let's start with code splitting in tan stack router. So code splitting as you may know is a technique for improving the bundle size and load performance of your application.
(2:52:07) So with code splitting we can reduce the amount of code uh that we need to load initially when we first load our application so that our application can load faster and then later when we request certain routes in our application we can load more chunks of code on demand. So stack router separates code into two categories. critical route configuration and non-critical route configuration. So critical route configuration is the code that is required to render the current route and kick off the data loading process as early as possible. So for example, when we define a route, we have our route definition, we have our search
(2:52:38) parameters validation, we have our loader function context and so on. All of these things are critical. So they should exist in the main bundle of our application and code splitting should not be applied to them. However, we have also non-critical route configuration.
(2:52:58) For example, the route component itself that we define in order to render our route, the error component, the pending component, not found component and so on. The code for these is nonritical to match the route and therefore we can load it on demand. We can code split it. So we don't have to include all of these components for all of our routes in our main bundle.
(2:53:17) So of course you can read more about code splitting here. However, let's maybe see it in action uh by going in here. And what I need to do is remember in our about route uh so in here about we had this example where we uh did a redirection to posts we were just testing this navigate component but uh let's remove this for now since we are going to use the about route in our example.
(2:53:42) So now we can normally go to about and now let's go back to home and let's maybe refresh and let's open our uh network tab. So let's open our network tab here. And while we have it opened, let's navigate to about. As you can see, when we navigated uh to about, nothing happened in our network. Nothing was loaded because currently we are not enabling code splitting.
(2:54:07) So all the code for this about route including the route component. Uh if we have a not found component and so on, all of that is going to be included in the main bundle. However, we can enable code splitting in order to make our main bundle a little bit slower or sorry, a little bit smaller and split the code for our routes into smaller chunks. And to do that, we can go into our vit config.
(2:54:30) So, vit config and in here in 10 stack router we can enable code splitting by adding here uh auto code splitting and set it to true. By doing this uh we might need to restart the server or actually it uh looks like it automatically restarted. Now let's try to go back to home refresh and let's clear our network tab and let's now navigate to about and as you can see we have some stuff going on here.
(2:55:01) We have the component for about loaded on demand when we navigate to about. So as you can see here we have the component for about. If we take a closer look here, we're going to find uh maybe the route component here. And maybe if we search for uh the about text that we have, we might actually find it here as well.
(2:55:22) So remember we had uh in here an H3 tag with about text. Here we here we have it an H3 tag and we have our about text and our classes and so on. So it looks like the code for this component was loaded on demand since we are now doing the automatic code splitting. Let's also try it with another route and uh this is the post route.
(2:55:50) So remember in our single post route which is posts uh post ID we had some more stuff. So remember we had the pending component as well and we also have the error component and not found component. All of these are going to be uh code split as well. So if we go to slashposts and try to visit posts uh try to visit some single posts.
(2:56:09) So let's clear our network and in our list of posts let's visit post one. No as you can see in addition to the network request that fetches the post and the comments we also have requests to fetch the post component. And these are the other components as well. the uh error component, not found component and so on.
(2:56:33) Now, if we let's maybe clear this and let's go back and let's go to another post. So, let's go here to post two, for example. Now, as you can see, we only get the network requests for the uh post itself and the comments and and we did not get the requests for the components. Why? Because these are the same components that we used when we loaded post one.
(2:56:57) Remember post one and post two are both are both using the same route and the same components. So we don't need to load them every time we visit a different post. All right. So that's mainly it. However, you can do further customizations if you would like. So in here as you can see uh in this uh documentation page here we can customize how auto code splitting works by specifying what exactly uh to code split.
(2:57:27) So in here uh we have these things that we can code split the uh main component for the route the error component pending component not found component all of these are going to be code split by default. We can also code split uh the loader as well the loader function. However, this is not actually recommended.
(2:57:45) And if we go down here, uh we're going to see examples on uh customizing the behavior which we can do globally by going into our V config and changing the default behavior here or we can also have programmatic control by passing a function instead. And so we can do it differently maybe for different routes.
(2:58:04) So we can pass a function here split behavior where we're going to get the route ID and maybe based on the route we need to split uh certain things for this route. However, I guess most of the time maybe the default behavior would be enough. But what you can also do if you would like uh you can also find this link here where you can control exactly what to code split if you are not using auto code splitting.
(2:58:33) So if you for some reason are not able to use the automatic uh code splitting feature in your V configuration, you can still code split your route files by adding this lazy.tsx suffix. And you have examples here on how to do that. So for example, this is how we would normally uh define a route. But let's say we would like to code split the component the component for the route but not code split the loader.
(2:58:56) Then we're going to need to split our file uh split this file into two files. One for critical things like the loader in our example and one for non-critical things that can be codeplit like the component. So in this case we're going to have this posts.tsx file that is going to contain the loader and a posts.lazy.
(2:59:16) tsx tsx file uh where we're going to create lazy file route instead of create fire route and then pass the things that we need to code split like the component. So this is how you can do it manually if you are not enabling auto code splitting for some reason.
(2:59:36) However, by enabling auto code splitting all of that is going to happen for you behind the scenes uh for all of your routes. And now that we know about code splitting let's also talk about preloading. And this is something that you might also be familiar with in other uh frameworks if you have worked with Nex.js for example. This is where the router is going to load the code and the data for the route before the user actually navigates to it. So that when the user actually navigates they are going to load as fast as possible.
(3:00:03) So if we have maybe some links like here in our menu and we expect the user to visit one of these links before the user even clicks on the link the router is going to preload the data and the code for this route so that when he actually clicks when the user actually clicks it's going to almost be instant and this happens by few ways.
(3:00:25) One of them is by hovering just by hovering over a link then maybe it is safe to assume that the user is going to click on this links. Once the user hovers, we can preload. It can also be done for all links in a certain page. So when we visit a certain route, any link that exists in this route, we can preload the code and data for it.
(3:00:44) And also another way is when a link appears in the viewport. So if you are scrolling in a route and a link appears without even hovering, we are just going to preload the data for uh the route that this link points to. So let's see that in action. Let's go to this uh about link. Remember this lived in our uh root route.
(3:01:09) And in here in the about link which is this one we can add this property preload and as a value we have intent render viewport. Intent means that uh the code for the route is going to load when we hover over this link. So let's maybe uh give it a refresh. Let's clear our network and let's only hover over about here. And as you can see the code for about was loaded.
(3:01:37) So this is of course assuming we are enabling code splitting and we need to load the component for the route or if we have some data in this route uh in the loader function the loader function is also going to run and the data is going to be pre-loaded as well. So let's actually maybe also try it just to clarify this. Let's try it in the posts route.
(3:01:56) posts.index.tsx. And in this links, let's go to this route here. So, slashposts. And for these links, let's clear our network tab. And let's add for these links uh h sorry preload intent as well. And let's clear our network. And let's hover. And as you can see, all the components were loaded.
(3:02:28) the not found component and the error component and the main component and so on and in addition to that the network requests to fetch the post and the comments as well. So whatever we have in our load function also uh was also preloaded as well. But we also have another option. So let's maybe uh let's maybe keep it simple and try it here in the homepage. Clear everything and in the root route let's change the about uh link the preload in about link instead of intent to render and render means that just by this link existing in the page it is going to be preloaded when we visit the route. So if
(3:03:06) we refresh now and take a look here somewhere we're going to find our about route uh loaded. So here it is. As you can see we have our about.tsx tsx file loaded. So now if we clear our network however nothing is going to be loaded because it is already loaded when we just uh visited the home route which has the about uh link just existing here without even having to hover over it.
(3:03:35) It is going to be preloaded. The other option that we have is viewport. This is where the route is going to be preloaded when the link appears in the viewport. And for this one, uh, I'm going to add somewhere here, let's say, uh, maybe before this navigation, I'm going to add a very large div here just to be able to scroll.
(3:03:58) And then, uh, in here, I'm going to add viewport as a value for preload. Now, let's save this. Let's refresh. Let's clear our network. And let's keep loading uh, or sorry, scrolling. And as long as our link appears in the network tab, we should have our request for about as you can see here. But of course, we will not have to add this preload uh prop for all of our links.
(3:04:24) We can let's actually remove this. And let's also remove the one that we added in the posts index. And what we can do is we can go into our main.tsx file. When we define our router, we can specify an option here of default preload. So default preload and whatever we're going to specify here is going to be applied to all of our links.
(3:04:52) So if we added the intent here uh let's also sorry let's remove this uh div that we added. Now without even having the preload attribute on the link when we hover over it is going to load. And for any link that we have, let's try the posts. If we hover over any post, we're going to get the data and the files loaded for uh this route.
(3:05:18) We can also we have an option here uh which is default preload delay. So default preload delay. This one if you would like to add a delay before your data is preloaded. So when you hover, let's say you would like to wait for maybe a second before pre-loading the data. You can specify this here. So let's save. Let's hover over about. As you can see, you will have to hover for a second for your data to preload.
(3:05:43) If we let's maybe refresh again, just hover for a for less than a second, then it is not going to preload. So this is maybe also something that you would like to do to maybe avoid unnecessary preloading. Also some other options that you can set here are options related to caching. So when we preload a route. So let's say uh let's refresh here. Let's maybe hover over about.
(3:06:09) Now as you can see it is preloaded. If we hover over it again it is not going to preload again until a certain amount of time has passed. It is going to be cached for some time. And we can control this cache by using the default preload max age here which is 30 seconds by default.
(3:06:29) After 30 seconds, any cached uh pre-loaded routes are going to be removed. And also we can control um how long preloaded data is considered fresh by using these options. Default preload stale time in our uh create router when we define our router or preload still time if we would like to specify this option for a specific route and not for all of our routes.
(3:06:52) But let's not get too deep into this because actually in the next section we're going to talk about caching in general in tanstack router. As we've mentioned in tanstack router we have built-in caching and this caching can be enough for uh as mentioned here small to medium-sized application.
(3:07:14) However, you can also integrate something like tanstag query for a more advanced caching solution if you need that. So if you are working on a project, make sure to take a look at uh maybe this page. Uh here we have the pros and cons listed for the caching that comes with tanstack router by default.
(3:07:33) And so by reading this, you can probably decide if you can use this caching or you need to use something like tanstack query with tanstack router. However, what we're going to do is we're going to discuss the built-in cache uh in 10stack router. We're not going to use tanstack query for this video. So let's take a look at this default caching. Let's go back to our application and uh let's maybe uh let's actually keep here in this post route and let's say uh the post is going to take some time to load for example.
(3:07:57) So we can go to our post post id route and we can make this a little bit slower by maybe in our loader function in here. Let's add some artificial delay in here like so. So now let's maybe give it a refresh. If we visit um any post, it is going to take some time to load. However, after loading, it is going to be cached.
(3:08:23) So, if we go back and visit the same post again, as you can see, it did not take any time to load. So, in 10 stack router, we have this uh still while revalidate caching by default, which means if we have something in the cache, we're going to serve it and then refresh our data in the background. So if we take a look at our network here, let's clear uh let's go back and clear our network.
(3:08:45) If we visit this post again, as you can see, we got something instantly. However, the load function still ran and after 3 seconds, we got our requests here. So even though we got something from the cache, we still refresh our data every time. And this is referred to as still while revalidate or SWR.
(3:09:05) But this cache, however, only lives in memory. uh once we refresh our page it is going to be gone. So let's go back for example refresh and if we click on the same post again now it's going to load again nothing is going to be served from the cache because the cache is gone since we have refreshed our page and of course we have some options to play around with the caching settings how long should it live and so on.
(3:09:32) So in order to demonstrate these options, let's have a quick example here by creating a route that displays a random word. So in here I'm going to create a new route. So uh let's say in our routes create a new file. I'm going to call it random dashword also and tsx of course. And I'm not going to write this from scratch. I'm just going to put some stuff here. It is pretty basic.
(3:10:00) We have a route that has a loader function. In this loader function, I make it a little bit slow by adding a delay of 1 second here, just of course to demonstrate caching. And then I found this API that generates a random word. I'm using this to return this random word from our loader function.
(3:10:18) And then I'm accessing this random word uh using loader data to display it in this route component. So by saving this if we go to / random route or random word we should find uh so sorry the API that I was using was not responding when I was recording. So uh I just replaced it with another one.
(3:10:41) If this is also not working with you, you are going to find others as well. But anyways uh now if we have this we're going to find a random word here and every time refresh it should be a new one. So now what I'm going to do, I'm going to go to my menu. This one uh that contains home and about. I'm going to put a link to our random word um route.
(3:11:04) So in here, I'm going to go to my root route and I'm going to add this link after about here to take us to the random word route like so. Now if we let's say go to the about route and then go back to random word we should be served the cached word and then a new word is going to be fetched in the background. So if we click now we're getting this.
(3:11:29) If we go back to about and then go to random word we're going to get the same word uh and then a new word is going to be fetched in the background and that's why I added this delay in order to see that we're going to get the cached word initially. So now we have a simple example in order to see the options that we can change in caching. However, before doing that, I also need to add one more thing.
(3:11:47) I need to add a search parameter here that we depend on in order to display our word. So let's say we're going to have a lang search parameter in order to change the language of the word. And this is going to be important because we need if we have a different language here to have a different cache for each language so that we don't get um a wrong language from our cache when we get uh when we get served a cacheed word here.
(3:12:12) So remember we have discussed that before that when we depend on something in our search parameter we do it in a specific way. But let's first uh I'm going to do it quickly add my search parameter. Remember how to do that? We create a schema using zod. So let's actually import dot like so and my schema uh my lang my my um search parameter is going to be called lang and it's going to be one of these English, Spanish, French and Chinese.
(3:12:40) I'm also going to add this lang type which is going to infer the type script type of this lang parameter from the from the zot schema using z.infer uh and therefore we're going to get this English uh Spanish French Chinese or undefined. We're going to use this later. And then remember uh we just add here a validate search option and we use zod validator and pass it our schema which is this like so.
(3:13:08) But now in our loader function we need to use this search parameter and add here in addition to this words parameter add a language parameter as well uh which is going to be a variable. So let's uh change this to a template and pass a variable here. However, remember we don't have access to search parameters in here and we've mentioned that this is for caching reasons.
(3:13:33) If we would like to have dependencies from our search parameters, we do it this way. So we add loader dependencies here and in loader dependencies we can pause a function and in this function uh we can return an object. In this function, we're going to have access to our search parameters and we can return the lang that we can access from our search parameters lang like so.
(3:14:01) We do this in order for tenstack router to be aware of what we depend on on the search parameter. So it can create a separate cache for each search parameter separately and they are not going to be mixed up. So now in our loader function we are going to have access to this depend uh dependencies and we can just simply pass it here in this language.
(3:14:20) Uh I think I have an equals missing here. So language and then equals dependencies dot lang if it does not exist because I'm making it uh making it optional here. If it does not exist, let's fall back to English. So, sorry, fall back to English like so. So, now uh if we don't pass anything here, we're going to get an English word.
(3:14:52) If we however pass a lang of let's say French, we should get uh something in French. If we pass Chinese for example, we should get something in Chinese. And now if we let's say have a language switcher in this page, which I'm going to do quickly here. Uh maybe before displaying our word, I'm going to add this div. Uh let's import link.
(3:15:17) And we've seen something like this before. So no uh no need to type it from scratch. We're just looping through our languages. And here I'm using the lang type that I defined here. And I'm just uh displaying a link that goes to the same route. So here we have a dot into and we're just updating the uh search parameter which is lang to the lang in our loop currently which is going to be one of these.
(3:15:42) So by saving this we're going to have this language switcher. And now that we have um the lang search parameter as a dependency, if we switch between these, we're not going to get any um or we are going to get a separate cache for each one of these routes depending on the length that we pass here. So let's say uh let's maybe go to English and we're getting this word.
(3:16:08) If we go to Spanish, we're going to get a different word. If we go back to English, we're going to get the cast word that was cast in English and then we're going to get a new one in the background. And same if we go now to Spanish, we're going to get the old word that we got before and then a new one is going to be fetched in the background.
(3:16:27) And so our cache is going to take into consideration this lang parameter and it's going to create separate caches depending on this language parameter. But now that we have this example, let's now see what options we can change. uh in this default caching behavior that we get with tensac router. So we're going to try these options in this route.
(3:16:53) But any option that we're going to do here can be uh set globally as well when we define our router in our main.tsx file. So let's open our network tab here. We're going to need this a lot. And first of all, let's try something that we I think we've mentioned in the previous section which is preloading and caching. So as we know now when we hover over a route the uh data for this route is going to be fetched as you can see but when we hover again this is not going to happen again until some time has passed and by default this time is 30 seconds and we can change this by adding in here an
(3:17:29) option which is uh preload stale time. So preload stale time and let's set it uh for example to 5 seconds so that we can try and also let's uh maybe move this delay after our request so that we can just uh see our request in the network tab immediately without having to wait. And now let's try again. So let's maybe give it a refresh.
(3:17:54) Let's clear everything and let's hover over our random word route. We're going to get our stuff here. If we wait for 5 seconds over again, we should get our request again here. And uh if we wait for another 5 seconds, we should get it again. I think actually sorry, sorry for that.
(3:18:18) The delay that we're getting when we hover is from the option that I guess we set here. This one default preload delay. So let's remove this one. So now if we hover, we're going to get it. hover uh before 5 seconds is passed we shouldn't get it after 5 seconds we should get it and so on you get the idea so this is something that you can control another option that we can control is stale time so this is preload stale time which is for our pre-loaded data but we also have stale time uh which means the number of milliseconds that routes data should be considered fresh when attempting to load so for example let's go to our random word uh
(3:18:57) route here and we have a word here in English. If we go to Spanish, we are going to get something. When we go back to English, we should get the previous word which was already cached and then in the background a new one is going to be generated.
(3:19:17) Right? So by default, stale time is going to be zero which means the routes data is always going to be considered stale and is always going to be reloaded in the background. So every time we visit this route or we switch to any language, we're going to get a cast word first and then we're going to get a new word in the background because the cache data is always going to be considered stale.
(3:19:41) Right? So just to be clear on this uh because I feel like I have confused you uh let's go to the about route. Go to random word. As you can see we get a random word, right? Go back to about go back to random word. we're going to get the same word and then it's going to be loaded in the background because uh the currently cached word is going to be considered stale.
(3:20:00) But let's say and this is because stale time by default is zero. But let's say we need the cache word uh to not be considered stale so that we won't run another request in the background for a certain amount of time. We can control that with stale time. Let's set it maybe to let's say 30 seconds.
(3:20:19) Now, in this case, let's give that another try. Let's maybe go to about, go to random word. We're we're going to get a cast word. As you can see, let's try it again here. We're going to get this cast word. And it's not going to refresh in the background since we have a larger steel time. Now, when 30 seconds pass, now this uh word is going to be marked as still.
(3:20:45) and it's going to be refreshed in the background when it is served from the cache. So I hope this is clear. Another option that we have is GC time or garbage collection time and we can set this to also a number of milliseconds and this means the amount of time that the routes data should be kept in the cache before being garbage collected.
(3:21:04) By default, it is 30 minutes, which means if any cache route data has not been accessed within 30 minutes, it is going to be completely removed from the cache. And you can control this as well. By default, it is 30 seconds. Another thing I would like to mention is calling router.invalidate.
(3:21:22) So remember in this login uh login button for example which is uh I guess it was in our root when we login uh this is coming from our context which we pass I guess also in main.tsx in here remember we call router.invalidate calling router.invalidate invalidate is going to force all active route to rerun their loader functions immediately and mark every cached route as stale.
(3:21:50) So if we click on login now as you can see we got a new word here because calling route router invalidate is going to force any active load function to rerun and any cache to be marked as st. The final thing I would like to mention about these caching options is in your route, you can also have this uh should reload function that you can pause here in order to control when exactly to rerun your load function.
(3:22:20) So this offers more control beyond uh just specifying the stale time here by in this function returning true or false based on something and if you return true the load function is going to rerun and in here you are going to receive the same things that you receive uh in the before load function which we've seen before.
(3:22:40) So in here you are going to get your context, you're going to get your parameters, you're going to get your dependencies and so on. You're also going to get information about your route. Pretty much everything that you are going to need in order to maybe based on something here decide when exactly to rerun your loader function. But this is mainly what I wanted to mention regarding to these caching options.
(3:23:04) And of course, if you'd like to read more about caching, you're going to find uh sections in the documentation related to caching that you can take a look at. Let's now see how we would protect our routes if we have some sort of an authentication system. So, of course, currently we don't have a real authentication system. However, we have this button here where we have some state. So, remember in our um main.
(3:23:24) tsx file, we are having this user state here that we are passing as a context to our router provider in here. So, let's use this. Let's assume we have a real uh authentication system where this user is actually real and depend on this user to exist in order to know if we are logged in or not and based on that we're going to protect some routes and maybe in a later video if you would like maybe we can uh integrate some actual authentication uh with tanstack router.
(3:23:52) So as we know now we have our route tree in tanstack router. So let's maybe actually uh create another one here. So let's say we have our root route here. So this is our root and let's say we maybe have some route that is public. So maybe this is an about page also. And let's say I have some other route that we need to protect.
(3:24:16) So let's say this is protected. As we know now for every route we have a loader function that's going to load the data. But we also have a before load function. This before load function is going to be called as we know before loading any data for our route and before rendering the route.
(3:24:39) And therefore this will be a perfect place in order to check for authentication stuff since we have access to our context here as well. We can check for our context and based on that we can maybe redirect or throw an error inside of before load and by doing so the route is not going to render. And not only that, we can also protect a group of routes using layouts. So let's say we have maybe a group of routes here and all of these need to be protected instead of having to add a before load function for each one of them and check for authentication and so on.
(3:25:10) What we can do is we can add a parent here a parent layout for all of these functions or all of these routes like so. And in here in this layout we can add a before load function. And in this before load function we can check for authentication. And if we throw an error here none of the children will attempt to load. So we can use layouts in order to protect multiple routes as well.
(3:25:35) So let's actually see that in action. So first of all I'm going to add a new uh route here for login. So I'm going to add a login route. New file login.tsx. tsx and we're just uh going to put the same button that we have here. So remember in our root we had this login button. We can do the same thing.
(3:25:59) Let's actually copy this and in this login route let's put a login button. And how we get access to login is remember using context. Since you are passing this login function as a context in our root it's going to be available everywhere. So we can just in here from our route dot uh sorry route dot use context use route context we can get our login function like so.
(3:26:33) And now by saving this we can go to /lo and we're going to have this login page. If we click login we should be logged in. Of course, when we log in, we should uh redirect to somewhere else and also we should not be able to access this login route if we are already logged in. But uh let's work on that in a moment.
(3:26:52) First, let's maybe try to protect a route based on our context by adding a forload function for the route that we need to protect. Let's say maybe let's do it for the about route. So let's say this is a protected one. So let's go to about.tsx in here. And what we need to do is we need to add a before load function. In here we're going to have access to our context.
(3:27:12) Right? So inside of here we can get our context and we can simply check if we don't have a user. So if not context do user. Let's assume we are logged out. And in order to prevent the data from loading and the route from rendering, we need to either throw an error or we can also do a redirect by throwing a redirect in here.
(3:27:37) Uh and redirect we can import it from 10 stack react router like so. In here we can pass of course where we need to redirect to. So we can pass to here and let's redirect to maybe the login route. So now if we save this and try to access about we are redirected to the login page. Right now when we click on login let's say we need to redirect to the route that we were trying to access.
(3:28:06) So let's say we were trying to access uh as we've seen here the protected route which is /about. We're going to be redirected to login since about is protected. So let's say when we actually login we need to go to the page that we were trying to access which is about.
(3:28:22) So in order to do that we need to pass the page that we were trying to access as a search parameter here in our login route. So let's do that by when redirecting here add a search parameter and then let's call it maybe redirect and then in here let's pass the location of the about route which we can get access to from here. We can have access to location and we can redirect to location.h.
(3:28:48) If we now save this and try to access about. So let's try to access about in here. Now we are redirected to login. But we have this search parameter redirect and it points to the about route. Now when we login we need to get this if it exists and redirect to it. Otherwise maybe have a default uh place to redirect to.
(3:29:11) let's say the home route also. So in our login route, let's say after logging in, let's maybe put uh curly brackets here. And after logging in, let's say we need to navigate. So in order to do that, we can use uh the use navigate hook. So in route, we have access to use navigate. And in here, we can do our navigation. However, let's also not forget that now since we have a search parameter for this route, we need to define the schema for it. So, I'm going to put this here and import zod. We're going to have a redirect which is optional. And then we
(3:29:49) just need to add validate search here. Import zod validator if you are using zod and pass it the schema. And now that's finally in here after logging in. Let's navigate to so let's pause here too and let's get the redirect search parameter which we can get from our hook as well. So from our use search hook.
(3:30:19) So in route we have our use search in here we are going to have access to redirect which is going to be uh which can be undefined. So we need in here to either redirect to this or fall back to the home route like so. So now when we click on login we should be redirected to about. Now that we are logged in we are able to see our about route normally.
(3:30:40) Of course if we refresh since we're not persisting this we're going to be logged out. Let's now simulate that we're logged in initially by going here in our root um and uh in here when we pass our context our user context which was in um sorry it was actually in our main.tsx file. In here, let's in instead of null, let's pass any maybe dummy user like so.
(3:31:04) And now when we refresh, we should be logged in and we should be able to visit the about route. The problem now is if we navigate to login, we are going to be able to navigate to login even though we are logged in. So we need in our login route as well to add a before load function and check if we are already logged in. We should not be able to see this route.
(3:31:27) So in here we can also get access to our context. Let's also get access to our search parameter so that we can navigate to the redirect search parameter if we have it. So now we can check if context user if we are already logged in. Let's throw a redirect and go to um search redirect or sorry or our homepage like so. Uh I think I have a an arrow missing here.
(3:32:04) Yeah. So now if we try to navigate to login, we should go back to the home route. Now let's say we are in the about route and we're logged in and of course about is protected as we've done and let's say we click on log out. Now remember when we click on log out uh uh sorry in main.tsx remember when we log out we call router.invalidate and as we've mentioned router.
(3:32:29) invalidate is going to force any active route to reload. So when we click log out now we're going to be redirected since our about route is going to reload and uh we're going to have our check here which is going to redirect us to the login since we are logged out now and we don't have a user in our context. So this is looking fine.
(3:32:55) Let's do the other uh option that we have here which is protecting multiple routes using layouts as well. So, as we've mentioned, in order to do that, in order to protect multiple routes with a layout, we need to add a parent to the routes that we need to protect. And this parent can either be a postless layout or just a normal parent route that can have a path as well.
(3:33:14) So, let's go back in here and let's say in our about route, I'm going to remove this protection that we have here. So, now about is not protected. And uh let's do this in the other way. So now I'm uh let's also in our main.tsx log out initially by changing this back to null like so. So now we should be logged out and uh we are able to access about since we have removed this protection.
(3:33:46) Now what we can do is let's do it maybe with a postless layout. have a passwordless layout that performs the authentication checks and then if we need to protect any route we just make it a child of this layout. So in here let's go in our routes folder and let's create this botless layout.
(3:34:06) Remember to do that we use underscore and let's call it maybe authenticated sorry authenticated tsx. And in here, we're not going to do anything. We're just simply going to render our outlet so that we can render our children. But in the markup, we're not going to do anything else. What we're going to do, however, is a before load function here to do our check.
(3:34:30) And actually, this is going to be exactly the same uh as we've done here. So remember, we just check our context and redirect to login with our search parameter. We can actually copy this from here. Uh and let's keep it removed from about so that we can draw it using the layout. So in here, let's just paste this import redirect.
(3:34:55) And uh I guess this should actually be it. Now by adding this as a parent to any route, this before load function is going to run first before any children renders. And if you're not logged in, we're going to redirect and none of the children are going to be loaded or rendered. And so we can protect our routes this way. Let's write in the about route by making about a child of this authenticated uh route.
(3:35:19) Let's actually copy the name from here. And let's in here rename about to uh underscore authenticated.about. And now it is uh it should be a children of this layout um a child of this layout. And uh as you can see if we try to access about it should now be protected.
(3:35:47) We are redirected to login with our redirect search parameter as well. Why don't we maybe try it with another route as well? So let's say uh random word. This one we can access it since uh it is not protected. Let's say we need it to be protected. Then we can just rename this and in here put our authenticated layout random word.
(3:36:12) And now it should be protected as you can see and we are redirected to login with a redirect parameter of random word. Another option that we have is maybe uh when you try to access a protected route instead of redirecting to login maybe you just need to show an error. So what we can do is let's maybe comment before load for now in our authenticated layout.
(3:36:37) So now nothing is going to be protected. We can access about normally. Uh let's go to /ab about and we should be able to access about and let's say we just need to display a message uh that we're not that we don't have access instead of redirecting to login. Now what we can do is in our parent component the authenticated layout instead of rendering the children we can render this message instead.
(3:37:01) And remember in here we have access to our context using the hook. So we can access from route uh dot use context. We can get our user from here and we can do our check here as well. So let's maybe add this condition here. If not user, we're going to return this div instead. So, as you can see, it works.
(3:37:24) Let's try it for random word as well. And it seems to be working. However, if we take a look at our network uh in here, let's maybe go to about and uh clear and then let's go to random word. As you can see, we are not we're seeing this message. However, the network request for the uh random word was sent. And this is not good.
(3:37:50) Of course, if we have a protected route, we need to avoid the loader function of this protected route from running. Even though uh even if we don't display any content, we need to avoid the loader function from running. So, we can either go to our uh our random word route and in our loader function, we have access to our context here. So, maybe before loading any data, we can check our context, make sure we are logged in.
(3:38:17) Or instead of having to do that for all protected route, we can maybe also instead of displaying our message like so, we can get our before load function back in our layout in our authenticated layout. However, what we're going to do here is instead of redirecting, so let's actually have our function get our context and uh let's add this check if you're not logged in. Instead of redirecting, we can just throw an error.
(3:38:48) So by throwing an error here, this is going to prevent any child load function from running. So let's throw a new error and let's say maybe o error or so. But now if we save this um and try to access random word for example, we're going to get the error like so. We're not going to get this because this component is not going to be even rendered. So what we need to do instead is pass an error component.
(3:39:16) And in the error component, you can check the error, check if it's an authentication error. You can display an authentication error because it can be another error as well. However, I'm just going to keep it simple and assume we have an authentication error and just display this message in our error component.
(3:39:35) So now if we try to refresh, we should get this. And now we can maybe remove this check from here. All right. And also to make sure let's go to about then go to random word. As you can see, nothing is sent in our network. Uh let's also finally try to click on login here. And this should reload our route and it should be working now.
(3:40:05) So that's mainly it. If you have reached this part of the video, I hope you enjoyed it. uh we have covered mainly all of the important or main stuff for tenstack router. However, we haven't covered even everything. So we have stuff like maybe route masking that you can take a look at if you would like.
(3:40:25) This is where you navigate to a certain route but you mask your URL to a different path. This can be used uh for models for example to display a route in a model. We also have some TypeScript utilities that you can use in order to maybe as you can see here validate link options if you are creating custom components and you need to uh have your components typed and so on.
(3:40:43) Uh we also have navigation blocking for example and this can be used if you need to block navigating to uh or navigating away from a certain route if you for example have unsaved changes. So you need to warn the user before he navigates away. Uh here we also have a guide to creating uh to creating custom links instead of the default link component that we have and we have some examples with maybe libraries like chakra UI uh MUI and so on.
(3:41:11) We also have a guide here for managing the document head. Uh this is for uh mainly for SEO stuff the title metatags and so on. And also we have this feature which is virtual file routes. And this can allow you to create your own um naming conventions for your file system here for your routing.
(3:41:37) By default, of course, we have this naming conventions where we name things with underscores, dots, and so on. You can even change this and create your own conventions using this feature as well, which you can read more about here. And of course, finally, we have the server side rendering stuff. However, if you have an application where you need server side rendering, you are probably going to use uh tanstack full stack framework which is tenstack start uh which we can see here. It is currently in beta.
(3:42:03) I also think we might do a video about this uh but probably when it is out officially. But thanks for watching again and uh please if you like this video uh leave a like, maybe a comment, subscribe to the channel. I'm planning to do more content similar to this one.
